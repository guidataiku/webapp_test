import { ChangeDetectorRef, ComponentRef, DestroyRef, DoCheck, ElementRef, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChanges, TemplateRef } from '@angular/core';
import { CdkOverlayOrigin, Overlay, ScrollStrategyOptions } from '@angular/cdk/overlay';
import { RdsAutocompleteContainerComponent } from './autocomplete-container.component';
import { BehaviorSubject, noop, Observable } from 'rxjs';
import { RdsAutocompleteIntl } from './autocomplete-intl.service';
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { RdsAbstractFormFieldControl } from '../form-field';
import { RdsControlType } from '../form-field/control.type';
import { ControlValueAccessor } from '@angular/forms';
import { RdsAutocompleteNewItemTemplateContext, RdsAutocompleteOptionTemplateContext, RdsAutocompleteTemplateContext } from './autocomplete.types';
import { RdsAutocompleteOptionDirective } from './autocomplete-option.directive';
import * as i0 from "@angular/core";
export declare abstract class RdsAbstractAutocompleteComponent<T, ArrayOfFlatType extends T | T[]> extends RdsAbstractFormFieldControl<ArrayOfFlatType> implements OnInit, ControlValueAccessor, DoCheck, OnChanges, OnDestroy {
    protected readonly cdr: ChangeDetectorRef;
    protected readonly overlay: Overlay;
    protected readonly destroyRef: DestroyRef;
    protected readonly config: {
        debounce: number;
        minSearchChars: number;
        optionsContainerMaxHeight: number;
        optionsContainerMinWidth: number;
        multiMinimumInputWidth: number;
        multiMinimumInputWidthOffset: number;
    };
    protected readonly intl: RdsAutocompleteIntl;
    protected readonly formField: import("../form-field").RdsFormFieldComponent<unknown>;
    protected readonly scrollStrategyOptions: ScrollStrategyOptions;
    options: T[] | ((query: string) => Observable<T[]>);
    displayProperty: keyof T | ((value: T) => string);
    uniqProperty: keyof T | ((value: T) => string | number);
    compareItem: (i1: T, i2: T) => boolean;
    filterBy: (item: T, query: string) => boolean;
    highlightQuery: boolean | 'inverse';
    newItem: (query: string, fetchedCollection: T[]) => T;
    selectNewItemOnBlur: boolean;
    selectLastRemainingOnBlur: boolean;
    skipSearchValue: (query: string) => boolean;
    placeholder: string;
    loadingText: string;
    noDataText: string;
    newItemText: string;
    optionTemplate: TemplateRef<RdsAutocompleteOptionTemplateContext<T, ArrayOfFlatType>>;
    noDataTemplate: TemplateRef<RdsAutocompleteTemplateContext<T, ArrayOfFlatType>>;
    loadingTemplate: TemplateRef<RdsAutocompleteTemplateContext<T, ArrayOfFlatType>>;
    newItemTemplate: TemplateRef<RdsAutocompleteNewItemTemplateContext<T, ArrayOfFlatType>>;
    get attrDisabled(): boolean | null;
    set disabled(disabled: BooleanInput);
    get disabled(): boolean;
    set debounce(debounce: NumberInput);
    get debounce(): number;
    private _debounce;
    set minSearchChars(minSearchChars: NumberInput);
    get minSearchChars(): number;
    private _minSearchChars;
    readonly hostClass = "w-100";
    readonly controlType: RdsControlType;
    protected typing$: BehaviorSubject<boolean>;
    openChanged: EventEmitter<boolean>;
    shown: EventEmitter<void>;
    hidden: EventEmitter<void>;
    typing: Observable<boolean>;
    loading: BehaviorSubject<boolean>;
    protected inputEl: ElementRef<HTMLInputElement>;
    protected inputContainer: ElementRef<HTMLDivElement>;
    abstract get values(): T[];
    get empty(): boolean;
    get shouldLabelFloat(): boolean;
    get errorState(): boolean;
    protected get inputAriaDescribedBy(): string;
    protected set inputAriaDescribedBy(newValue: string);
    _trigger: ElementRef<HTMLDivElement>;
    _origin: CdkOverlayOrigin;
    private _inputAriaDescribedby;
    onChange: (value: ArrayOfFlatType) => void;
    onTouched: typeof noop;
    protected _value: ArrayOfFlatType;
    protected _newValues: T[];
    protected _open: boolean;
    private _overlayRef;
    private _portal;
    protected _dropdownInstance: ComponentRef<RdsAutocompleteContainerComponent<T, ArrayOfFlatType>>;
    protected _options: T[];
    protected _onFocusInputValue: string;
    protected _search$: BehaviorSubject<string>;
    private _lastValues;
    private readonly _closed$;
    constructor();
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngDoCheck(): void;
    ngOnDestroy(): void;
    protected focusChanged(isFocused: boolean): void;
    show(): void;
    hide(): void;
    hasValue(): boolean;
    isSelected(option: T): boolean;
    abstract deselect(option?: T): void;
    clear(): void;
    protected abstract setValueForClear(): void;
    abstract select(option: T): void;
    selectNewItem(): void;
    getNewItem(): T | null;
    registerOnChange(fn: (value: ArrayOfFlatType) => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    writeValue(v: ArrayOfFlatType): void;
    abstract isInputFilled(): boolean;
    getInputFilledValue(): string;
    getDisplayProperty(v: T | null): string;
    getUniqProperty(v: T | null): string | number;
    onContainerClick(): void;
    setDescribedByIds(ids: string[]): void;
    getSearchQuery(): string;
    updatePosition(): void;
    clearValue(event?: Event): void;
    toggle(option: T): void;
    get required(): boolean;
    _addOption(option: HTMLElement, component: RdsAutocompleteOptionDirective<T, ArrayOfFlatType>): void;
    _deleteOption(option: HTMLElement): void;
    protected onValueChange(force?: boolean): void;
    protected addNewItemOnBlurAndHide(): void;
    protected addNewItemOnBlur(query?: string): void;
    protected getPlaceholder(): string;
    protected search(query?: string): void;
    protected onInputKeydown(event: KeyboardEvent): void;
    private _filterBy;
    private searchFn;
    protected getNewNotQueriedSelectedValues(options: T[]): T[];
    protected updateDropdownOptions(): void;
    private getPositionStrategy;
    private getPositions;
    protected assignInputsToDropdown(): void;
    private updateSearch;
    private isNativelyBadInput;
    protected hasAtLeastOneDifferentItem(arrayA: T[], arrayB: T[]): boolean;
    protected focus(options?: FocusOptions): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<RdsAbstractAutocompleteComponent<any, any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RdsAbstractAutocompleteComponent<any, any>, never, never, { "options": { "alias": "options"; "required": true; }; "displayProperty": { "alias": "displayProperty"; "required": false; }; "uniqProperty": { "alias": "uniqProperty"; "required": false; }; "compareItem": { "alias": "compareItem"; "required": false; }; "filterBy": { "alias": "filterBy"; "required": false; }; "highlightQuery": { "alias": "highlightQuery"; "required": false; }; "newItem": { "alias": "newItem"; "required": false; }; "selectNewItemOnBlur": { "alias": "selectNewItemOnBlur"; "required": false; }; "selectLastRemainingOnBlur": { "alias": "selectLastRemainingOnBlur"; "required": false; }; "skipSearchValue": { "alias": "skipSearchValue"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "loadingText": { "alias": "loadingText"; "required": false; }; "noDataText": { "alias": "noDataText"; "required": false; }; "newItemText": { "alias": "newItemText"; "required": false; }; "optionTemplate": { "alias": "optionTemplate"; "required": false; }; "noDataTemplate": { "alias": "noDataTemplate"; "required": false; }; "loadingTemplate": { "alias": "loadingTemplate"; "required": false; }; "newItemTemplate": { "alias": "newItemTemplate"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "debounce": { "alias": "debounce"; "required": false; }; "minSearchChars": { "alias": "minSearchChars"; "required": false; }; }, { "openChanged": "openChanged"; "shown": "shown"; "hidden": "hidden"; "typing": "typing"; "loading": "loading"; }, never, never, false, never>;
    static ngAcceptInputType_selectNewItemOnBlur: unknown;
    static ngAcceptInputType_selectLastRemainingOnBlur: unknown;
}
