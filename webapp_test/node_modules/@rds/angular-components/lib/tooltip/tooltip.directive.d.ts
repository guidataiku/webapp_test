import { AriaDescriber, FocusMonitor, FocusOrigin } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { Overlay, ScrollDispatcher, ScrollStrategy } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import { AfterViewInit, DestroyRef, ElementRef, NgZone, OnDestroy, Renderer2, TemplateRef, ViewContainerRef } from '@angular/core';
import { RdsTooltipComponent } from './tooltip.component';
import { RdsTooltipClass, RdsTooltipPosition, RdsTooltipTouchGestures } from './types';
import * as i0 from "@angular/core";
export declare class RdsTooltipDirective implements OnDestroy, AfterViewInit {
    protected readonly overlay: Overlay;
    protected readonly elementRef: ElementRef<HTMLElement>;
    protected readonly scrollDispatcher: ScrollDispatcher;
    protected readonly viewContainerRef: ViewContainerRef;
    protected readonly ngZone: NgZone;
    protected readonly platform: Platform;
    protected readonly ariaDescriber: AriaDescriber;
    protected readonly renderer: Renderer2;
    protected readonly destroyRef: DestroyRef;
    protected readonly focusMonitor: FocusMonitor;
    protected readonly scrollStrategy: () => ScrollStrategy;
    protected readonly defaultOptions: import("./types").RdsTooltipDefaultOptions | null;
    protected readonly document: Document;
    protected readonly isPopover: boolean;
    protected _hasBackdrop: boolean;
    protected _showCloseButton: boolean;
    /** Manually-bound passive event listeners. */
    private readonly _passiveListeners;
    private _overlayRef;
    private _touchstartTimeout;
    private _portal;
    private _tooltipClass;
    private _disabled;
    private _viewInitialized;
    private _pointerExitEventsInitialized;
    private _content;
    private _position;
    protected origin: FocusOrigin;
    _tooltipInstance: RdsTooltipComponent | null;
    ariaDescription: string;
    showDelay: number;
    hideDelay: number;
    protected _hideArrow: boolean | null;
    set hideArrow(shouldHideArrow: BooleanInput);
    get hideArrow(): boolean;
    /**
     * How touch gestures should be handled by the tooltip. On touch devices the tooltip directive
     * uses a long press gesture to show and hide, however it can conflict with the native browser
     * gestures. To work around the conflict, Angular Material disables native gestures on the
     * trigger, but that might not be desirable on particular elements (e.g. inputs and draggable
     * elements). The different values for this option configure the touch event handling as follows:
     * - `auto` - Enables touch gestures for all elements, but tries to avoid conflicts with native
     *   browser gestures on particular elements. In particular, it allows text selection on inputs
     *   and textareas, and preserves the native browser dragging on elements marked as `draggable`.
     * - `on` - Enables touch gestures for all elements and disables native
     *   browser gestures with no exceptions.
     * - `off` - Disables touch gestures. Note that this will prevent the tooltip from
     *   showing on touch devices.
     */
    touchGestures: RdsTooltipTouchGestures;
    get position(): RdsTooltipPosition;
    set position(value: RdsTooltipPosition);
    set disabled(value: BooleanInput);
    get disabled(): boolean;
    get content(): string | TemplateRef<unknown>;
    set content(value: string | TemplateRef<unknown>);
    get tooltipClass(): RdsTooltipClass;
    set tooltipClass(value: RdsTooltipClass);
    get tooltipDescription(): string;
    get hasBackdrop(): boolean;
    set hasBackdrop(v: BooleanInput);
    get showCloseButton(): boolean;
    set showCloseButton(v: BooleanInput);
    private ariaControls;
    protected ariaExpanded: boolean | null;
    constructor();
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    show(delay?: number): void;
    /**
     * Hides the tooltip
     * @param delay ms
     */
    hide(delay?: number): void;
    /**
     * Shows/hides tooltip
     */
    toggle(): void;
    isHideArrowSet(): boolean;
    private isTooltipVisible;
    private handleHostKeydown;
    private createOverlay;
    protected handleFocus(): void;
    private updateTooltipStyling;
    protected restoreTriggerFocus(): void;
    private detachTooltip;
    private updatePosition;
    private getOrigin;
    private getOverlayPosition;
    private updateTooltipContent;
    private setTooltipClassIfTooltipInstanceExists;
    private invertPosition;
    private invertOffset;
    private setupFocusMonitor;
    private setupPointerEnterEventsIfNeeded;
    private setupPointerExitEventsIfNeeded;
    private addListeners;
    private platformSupportsMouseEvents;
    private wheelListener;
    private disableNativeGestures;
    private shouldHideArrow;
    static ɵfac: i0.ɵɵFactoryDeclaration<RdsTooltipDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<RdsTooltipDirective, "[rdsTooltip], [rds-tooltip]", ["rdsTooltip"], { "ariaDescription": { "alias": "rdsTooltipAriaDescription"; "required": false; }; "showDelay": { "alias": "rdsTooltipShowDelay"; "required": false; }; "hideDelay": { "alias": "rdsTooltipHideDelay"; "required": false; }; "hideArrow": { "alias": "rdsTooltipHideArrow"; "required": false; }; "touchGestures": { "alias": "rdsTooltipTouchGestures"; "required": false; }; "position": { "alias": "rdsTooltipPosition"; "required": false; }; "disabled": { "alias": "rdsTooltipDisabled"; "required": false; }; "content": { "alias": "rdsTooltip"; "required": false; }; "tooltipClass": { "alias": "rdsTooltipClass"; "required": false; }; }, {}, never, never, false, never>;
    static ngAcceptInputType_showDelay: unknown;
    static ngAcceptInputType_hideDelay: unknown;
}
