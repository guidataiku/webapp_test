import { ChangeDetectorRef, ContentChildren, DestroyRef, Directive, inject, Input, QueryList, } from '@angular/core';
import { map, skipWhile, startWith, takeUntil, withLatestFrom, } from 'rxjs/operators';
import { BehaviorSubject, Subject } from 'rxjs';
import { IntersectionObserverRx } from '../utils/intersection-observer.util';
import { RdsAnchorMenuSectionDirective } from './anchor-menu-section.directive';
import { ActivatedRoute } from '@angular/router';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
let nextId = 0;
const DEFAULT_OBSERVER_CONFIG = Object.freeze({
    rootMargin: '-10% 0px -70%',
    threshold: 0.02,
});
export class RdsAnchorMenuSectionsContainerDirective {
    constructor() {
        this.destroyRef = inject(DestroyRef);
        this.activeRoute = inject(ActivatedRoute);
        this.intersectionObserver = inject(IntersectionObserverRx);
        this.cdr = inject(ChangeDetectorRef);
        this._sections$ = new BehaviorSubject([]);
        this.killIntersectionSubscriptions$ = new Subject();
        this.activeSection$ = new BehaviorSubject(undefined);
        this.sections$ = this._sections$.asObservable();
        this.id = `rdsAnchorMenuSectionsContainer-${nextId++}`;
        this.scrollIntoViewOptions = {
            behavior: 'smooth',
        };
    }
    ngAfterContentInit() {
        this.sectionQuery.changes
            .pipe(startWith(this.sectionQuery), map((sections) => this.queryListToAnchorMenuSectionData(sections)), takeUntilDestroyed(this.destroyRef))
            .subscribe((v) => {
            this._sections$.next(v);
            // Force change detection cause otherwise we get ExpressionChangedAfterItHasBeenCheckedError"
            // Deferring value propagation helps only in case of initial value
            this.cdr.detectChanges();
        });
    }
    ngAfterViewInit() {
        this.activeRoute.fragment
            .pipe(map((fragment) => {
            return fragment
                ? this.sectionQuery.find((section) => section.id === fragment)
                : null;
        }), takeUntilDestroyed(this.destroyRef))
            .subscribe((target) => {
            if (!target) {
                return;
            }
            target._element.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
            if (typeof this.scrollIntoViewOptions !== 'object' ||
                this.scrollIntoViewOptions.behavior !== 'smooth') {
                // intersection observer might be confused in case of an instant scroll
                // we emit correct active section just a tiny bit after its events are handled
                setTimeout(() => {
                    this.activeSection$.next(target);
                }, 100);
            }
        });
    }
    ngOnDestroy() {
        this.killIntersectionSubscriptions$.complete();
    }
    queryListToAnchorMenuSectionData(list) {
        this.killIntersectionSubscriptions$.next();
        return list.map((section, index) => {
            this.createIntersectionObservable(section)
                .pipe(withLatestFrom(this.activeSection$), takeUntil(this.killIntersectionSubscriptions$), takeUntilDestroyed(this.destroyRef))
                .subscribe(([entry, activeSection]) => this.onIntersectionEvent(entry, index, activeSection));
            return {
                section,
                isActive$: this.activeSection$.pipe(map((active) => active === section)),
            };
        });
    }
    onIntersectionEvent(entry, sectionIndex, activeSection) {
        const section = this._sections$.value[sectionIndex].section;
        if (entry.isIntersecting) {
            const nextSection = this._sections$.value[sectionIndex + 1]?.section;
            if (nextSection && nextSection === activeSection) {
                // this is the event which occurs when previous section is entering intersection area
                // we want to ignore it because change is emitted when user scrolls further and the current section leaves
                return;
            }
            this.activeSection$.next(section);
            return;
        }
        if (this.isScrolledOutDownwards(entry)) {
            // user scrolls up, so the section is lower than rootBounds,
            // so we emit previous item as the active one
            const previousItemIndex = sectionIndex > 0 ? sectionIndex - 1 : 0;
            this.activeSection$.next(this._sections$.value[previousItemIndex]?.section);
        }
    }
    createIntersectionObservable(section) {
        // emit section once it's intersecting
        return this.intersectionObserver
            .observe(section._element.nativeElement, {
            ...DEFAULT_OBSERVER_CONFIG,
            ...this.intersectionObserverOptions,
        })
            .pipe(map((entries) => entries[0]), 
        // we don't need any information about the section until its first intersection,
        // it makes initialization process and active item logic harder to manage
        skipWhile((entry) => !entry.isIntersecting));
    }
    isScrolledOutDownwards(entry) {
        // honestly I haven't found any mention of rootBounds being nullable value in MDN
        // but Typescript says it could be null, so we're setting fallback value that should
        // be reasonable in most cases
        const rootBounds = entry.rootBounds ||
            {
                bottom: 200,
            };
        return (!entry.isIntersecting &&
            entry.boundingClientRect.bottom > rootBounds.bottom);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsAnchorMenuSectionsContainerDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.3.1", type: RdsAnchorMenuSectionsContainerDirective, selector: "[rds-anchor-menu-sections-container], [rdsAnchorMenuSectionsContainer]", inputs: { intersectionObserverOptions: "intersectionObserverOptions", scrollIntoViewOptions: "scrollIntoViewOptions" }, providers: [IntersectionObserverRx], queries: [{ propertyName: "sectionQuery", predicate: RdsAnchorMenuSectionDirective, descendants: true }], exportAs: ["rdsAnchorMenuSectionsContainer"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsAnchorMenuSectionsContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rds-anchor-menu-sections-container], [rdsAnchorMenuSectionsContainer]',
                    exportAs: 'rdsAnchorMenuSectionsContainer',
                    providers: [IntersectionObserverRx],
                }]
        }], propDecorators: { sectionQuery: [{
                type: ContentChildren,
                args: [RdsAnchorMenuSectionDirective, { descendants: true }]
            }], intersectionObserverOptions: [{
                type: Input
            }], scrollIntoViewOptions: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5jaG9yLW1lbnUtc2VjdGlvbnMtY29udGFpbmVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvYW5ndWxhci1jb21wb25lbnRzL3NyYy9saWIvYW5jaG9yLW1lbnUvYW5jaG9yLW1lbnUtc2VjdGlvbnMtY29udGFpbmVyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBR0wsaUJBQWlCLEVBQ2pCLGVBQWUsRUFDZixVQUFVLEVBQ1YsU0FBUyxFQUNULE1BQU0sRUFDTixLQUFLLEVBRUwsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxHQUFHLEVBQ0gsU0FBUyxFQUNULFNBQVMsRUFDVCxTQUFTLEVBQ1QsY0FBYyxHQUNmLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLGVBQWUsRUFBYyxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFN0UsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDaEYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUVoRSxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFFZixNQUFNLHVCQUF1QixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDNUMsVUFBVSxFQUFFLGVBQWU7SUFDM0IsU0FBUyxFQUFFLElBQUk7Q0FDaEIsQ0FBQyxDQUFDO0FBUUgsTUFBTSxPQUFPLHVDQUF1QztJQU5wRDtRQVNtQixlQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hDLGdCQUFXLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3JDLHlCQUFvQixHQUFH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c0IsQ0FBQztpQkFDcEM7OEJBb0JDLFlBQVk7c0JBRFgsZUFBZTt1QkFBQyw2QkFBNkIsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7Z0JBSXJFLDJCQUEyQjtzQkFEMUIsS0FBSztnQkFJTixxQkFBcUI7c0JBRHBCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29udGVudENoaWxkcmVuLFxuICBEZXN0cm95UmVmLFxuICBEaXJlY3RpdmUsXG4gIGluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIG1hcCxcbiAgc2tpcFdoaWxlLFxuICBzdGFydFdpdGgsXG4gIHRha2VVbnRpbCxcbiAgd2l0aExhdGVzdEZyb20sXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSeCB9IGZyb20gJy4uL3V0aWxzL2ludGVyc2VjdGlvbi1vYnNlcnZlci51dGlsJztcbmltcG9ydCB7IFJkc0FuY2hvck1lbnVTZWN0aW9uRGF0YSB9IGZyb20gJy4vYW5jaG9yLW1lbnUudHlwZXMnO1xuaW1wb3J0IHsgUmRzQW5jaG9yTWVudVNlY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL2FuY2hvci1tZW51LXNlY3Rpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IHRha2VVbnRpbERlc3Ryb3llZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUvcnhqcy1pbnRlcm9wJztcblxubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IERFRkFVTFRfT0JTRVJWRVJfQ09ORklHID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHJvb3RNYXJnaW46ICctMTAlIDBweCAtNzAlJyxcbiAgdGhyZXNob2xkOiAwLjAyLFxufSk7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjpcbiAgICAnW3Jkcy1hbmNob3ItbWVudS1zZWN0aW9ucy1jb250YWluZXJdLCBbcmRzQW5jaG9yTWVudVNlY3Rpb25zQ29udGFpbmVyXScsXG4gIGV4cG9ydEFzOiAncmRzQW5jaG9yTWVudVNlY3Rpb25zQ29udGFpbmVyJyxcbiAgcHJvdmlkZXJzOiBbSW50ZXJzZWN0aW9uT2JzZXJ2ZXJSeF0sXG59KVxuZXhwb3J0IGNsYXNzIFJkc0FuY2hvck1lbnVTZWN0aW9uc0NvbnRhaW5lckRpcmVjdGl2ZVxuICBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveVxue1xuICBwcml2YXRlIHJlYWRvbmx5IGRlc3Ryb3lSZWYgPSBpbmplY3QoRGVzdHJveVJlZik7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aXZlUm91dGUgPSBpbmplY3QoQWN0aXZhdGVkUm91dGUpO1xuICBwcml2YXRlIHJlYWRvbmx5IGludGVyc2VjdGlvbk9ic2VydmVyID0gaW5qZWN0KEludGVyc2VjdGlvbk9ic2VydmVyUngpO1xuICBwcml2YXRlIHJlYWRvbmx5IGNkciA9IGluamVjdChDaGFuZ2VEZXRlY3RvclJlZik7XG4gIHByaXZhdGUgcmVhZG9ubHkgX3NlY3Rpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UmRzQW5jaG9yTWVudVNlY3Rpb25EYXRhW10+KFxuICAgIFtdLFxuICApO1xuICBwcml2YXRlIHJlYWRvbmx5IGtpbGxJbnRlcnNlY3Rpb25TdWJzY3JpcHRpb25zJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWN0aXZlU2VjdGlvbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFxuICAgIFJkc0FuY2hvck1lbnVTZWN0aW9uRGlyZWN0aXZlIHwgdW5kZWZpbmVkXG4gID4odW5kZWZpbmVkKTtcblxuICByZWFkb25seSBzZWN0aW9ucyQgPSB0aGlzLl9zZWN0aW9ucyQuYXNPYnNlcnZhYmxlKCk7XG4gIHJlYWRvbmx5IGlkID0gYHJkc0FuY2hvck1lbnVTZWN0aW9uc0NvbnRhaW5lci0ke25leHRJZCsrfWA7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihSZHNBbmNob3JNZW51U2VjdGlvbkRpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICBzZWN0aW9uUXVlcnk6IFF1ZXJ5TGlzdDxSZHNBbmNob3JNZW51U2VjdGlvbkRpcmVjdGl2ZT47XG5cbiAgQElucHV0KClcbiAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJPcHRpb25zOiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQ7XG5cbiAgQElucHV0KClcbiAgc2Nyb2xsSW50b1ZpZXdPcHRpb25zOiBib29sZWFuIHwgU2Nyb2xsSW50b1ZpZXdPcHRpb25zID0ge1xuICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgfTtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5zZWN0aW9uUXVlcnkuY2hhbmdlc1xuICAgICAgLnBpcGUoXG4gICAgICAgIHN0YXJ0V2l0aCh0aGlzLnNlY3Rpb25RdWVyeSksXG4gICAgICAgIG1hcCgoc2VjdGlvbnMpID0+IHRoaXMucXVlcnlMaXN0VG9BbmNob3JNZW51U2VjdGlvbkRhdGEoc2VjdGlvbnMpKSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh2KSA9PiB7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25zJC5uZXh0KHYpO1xuXG4gICAgICAgIC8vIEZvcmNlIGNoYW5nZSBkZXRlY3Rpb24gY2F1c2Ugb3RoZXJ3aXNlIHdlIGdldCBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yXCJcbiAgICAgICAgLy8gRGVmZXJyaW5nIHZhbHVlIHByb3BhZ2F0aW9uIGhlbHBzIG9ubHkgaW4gY2FzZSBvZiBpbml0aWFsIHZhbHVlXG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlUm91dGUuZnJhZ21lbnRcbiAgICAgIC5waXBlKFxuICAgICAgICBtYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZyYWdtZW50XG4gICAgICAgICAgICA/IHRoaXMuc2VjdGlvblF1ZXJ5LmZpbmQoKHNlY3Rpb24pID0+IHNlY3Rpb24uaWQgPT09IGZyYWdtZW50KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9KSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxJbnRvVmlldyhcbiAgICAgICAgICB0aGlzLnNjcm9sbEludG9WaWV3T3B0aW9ucyxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRoaXMuc2Nyb2xsSW50b1ZpZXdPcHRpb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXdPcHRpb25zLmJlaGF2aW9yICE9PSAnc21vb3RoJ1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBpbnRlcnNlY3Rpb24gb2JzZXJ2ZXIgbWlnaHQgYmUgY29uZnVzZWQgaW4gY2FzZSBvZiBhbiBpbnN0YW50IHNjcm9sbFxuICAgICAgICAgIC8vIHdlIGVtaXQgY29ycmVjdCBhY3RpdmUgc2VjdGlvbiBqdXN0IGEgdGlueSBiaXQgYWZ0ZXIgaXRzIGV2ZW50cyBhcmUgaGFuZGxlZFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVTZWN0aW9uJC5uZXh0KHRhcmdldCk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmtpbGxJbnRlcnNlY3Rpb25TdWJzY3JpcHRpb25zJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgcXVlcnlMaXN0VG9BbmNob3JNZW51U2VjdGlvbkRhdGEoXG4gICAgbGlzdDogUXVlcnlMaXN0PFJkc0FuY2hvck1lbnVTZWN0aW9uRGlyZWN0aXZlPixcbiAgKTogUmRzQW5jaG9yTWVudVNlY3Rpb25EYXRhW10ge1xuICAgIHRoaXMua2lsbEludGVyc2VjdGlvblN1YnNjcmlwdGlvbnMkLm5leHQoKTtcblxuICAgIHJldHVybiBsaXN0Lm1hcCgoc2VjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuY3JlYXRlSW50ZXJzZWN0aW9uT2JzZXJ2YWJsZShzZWN0aW9uKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLmFjdGl2ZVNlY3Rpb24kKSxcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5raWxsSW50ZXJzZWN0aW9uU3Vic2NyaXB0aW9ucyQpLFxuICAgICAgICAgIHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLmRlc3Ryb3lSZWYpLFxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKFtlbnRyeSwgYWN0aXZlU2VjdGlvbl0pID0+XG4gICAgICAgICAgdGhpcy5vbkludGVyc2VjdGlvbkV2ZW50KGVudHJ5LCBpbmRleCwgYWN0aXZlU2VjdGlvbiksXG4gICAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlY3Rpb24sXG4gICAgICAgIGlzQWN0aXZlJDogdGhpcy5hY3RpdmVTZWN0aW9uJC5waXBlKFxuICAgICAgICAgIG1hcCgoYWN0aXZlKSA9PiBhY3RpdmUgPT09IHNlY3Rpb24pLFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgb25JbnRlcnNlY3Rpb25FdmVudChcbiAgICBlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSxcbiAgICBzZWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICBhY3RpdmVTZWN0aW9uPzogUmRzQW5jaG9yTWVudVNlY3Rpb25EaXJlY3RpdmUsXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9ucyQudmFsdWVbc2VjdGlvbkluZGV4XS5zZWN0aW9uO1xuXG4gICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICBjb25zdCBuZXh0U2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zJC52YWx1ZVtzZWN0aW9uSW5kZXggKyAxXT8uc2VjdGlvbjtcblxuICAgICAgaWYgKG5leHRTZWN0aW9uICYmIG5leHRTZWN0aW9uID09PSBhY3RpdmVTZWN0aW9uKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGV2ZW50IHdoaWNoIG9jY3VycyB3aGVuIHByZXZpb3VzIHNlY3Rpb24gaXMgZW50ZXJpbmcgaW50ZXJzZWN0aW9uIGFyZWFcbiAgICAgICAgLy8gd2Ugd2FudCB0byBpZ25vcmUgaXQgYmVjYXVzZSBjaGFuZ2UgaXMgZW1pdHRlZCB3aGVuIHVzZXIgc2Nyb2xscyBmdXJ0aGVyIGFuZCB0aGUgY3VycmVudCBzZWN0aW9uIGxlYXZlc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWN0aXZlU2VjdGlvbiQubmV4dChzZWN0aW9uKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU2Nyb2xsZWRPdXREb3dud2FyZHMoZW50cnkpKSB7XG4gICAgICAvLyB1c2VyIHNjcm9sbHMgdXAsIHNvIHRoZSBzZWN0aW9uIGlzIGxvd2VyIHRoYW4gcm9vdEJvdW5kcyxcbiAgICAgIC8vIHNvIHdlIGVtaXQgcHJldmlvdXMgaXRlbSBhcyB0aGUgYWN0aXZlIG9uZVxuICAgICAgY29uc3QgcHJldmlvdXNJdGVtSW5kZXggPSBzZWN0aW9uSW5kZXggPiAwID8gc2VjdGlvbkluZGV4IC0gMSA6IDA7XG4gICAgICB0aGlzLmFjdGl2ZVNlY3Rpb24kLm5leHQoXG4gICAgICAgIHRoaXMuX3NlY3Rpb25zJC52YWx1ZVtwcmV2aW91c0l0ZW1JbmRleF0/LnNlY3Rpb24sXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlSW50ZXJzZWN0aW9uT2JzZXJ2YWJsZShcbiAgICBzZWN0aW9uOiBSZHNBbmNob3JNZW51U2VjdGlvbkRpcmVjdGl2ZSxcbiAgKTogT2JzZXJ2YWJsZTxJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5PiB7XG4gICAgLy8gZW1pdCBzZWN0aW9uIG9uY2UgaXQncyBpbnRlcnNlY3RpbmdcbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlclxuICAgICAgLm9ic2VydmUoc2VjdGlvbi5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCB7XG4gICAgICAgIC4uLkRFRkFVTFRfT0JTRVJWRVJfQ09ORklHLFxuICAgICAgICAuLi50aGlzLmludGVyc2VjdGlvbk9ic2VydmVyT3B0aW9ucyxcbiAgICAgIH0pXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKChlbnRyaWVzKSA9PiBlbnRyaWVzWzBdKSxcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHNlY3Rpb24gdW50aWwgaXRzIGZpcnN0IGludGVyc2VjdGlvbixcbiAgICAgICAgLy8gaXQgbWFrZXMgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyBhbmQgYWN0aXZlIGl0ZW0gbG9naWMgaGFyZGVyIHRvIG1hbmFnZVxuICAgICAgICBza2lwV2hpbGUoKGVudHJ5KSA9PiAhZW50cnkuaXNJbnRlcnNlY3RpbmcpLFxuICAgICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNTY3JvbGxlZE91dERvd253YXJkcyhlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSk6IGJvb2xlYW4ge1xuICAgIC8vIGhvbmVzdGx5IEkgaGF2ZW4ndCBmb3VuZCBhbnkgbWVudGlvbiBvZiByb290Qm91bmRzIGJlaW5nIG51bGxhYmxlIHZhbHVlIGluIE1ETlxuICAgIC8vIGJ1dCBUeXBlc2NyaXB0IHNheXMgaXQgY291bGQgYmUgbnVsbCwgc28gd2UncmUgc2V0dGluZyBmYWxsYmFjayB2YWx1ZSB0aGF0IHNob3VsZFxuICAgIC8vIGJlIHJlYXNvbmFibGUgaW4gbW9zdCBjYXNlc1xuICAgIGNvbnN0IHJvb3RCb3VuZHMgPVxuICAgICAgZW50cnkucm9vdEJvdW5kcyB8fFxuICAgICAgKHtcbiAgICAgICAgYm90dG9tOiAyMDAsXG4gICAgICB9IGFzIERPTVJlY3RSZWFkT25seSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgIWVudHJ5LmlzSW50ZXJzZWN0aW5nICYmXG4gICAgICBlbnRyeS5ib3VuZGluZ0NsaWVudFJlY3QuYm90dG9tID4gcm9vdEJvdW5kcy5ib3R0b21cbiAgICApO1xuICB9XG59XG4iXX0=