import { Injectable, Optional, SkipSelf, } from '@angular/core';
import { DateAdapter } from './adapter';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "./adapter";
export class DateRange {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
export class RdsDateSelectionModel {
    constructor(_dateAdapter) {
        this._dateAdapter = _dateAdapter;
        this._selectionChanged = new Subject();
        this.selection = null;
        this.selectionChanged = this._selectionChanged;
    }
    updateSelection(value, source) {
        const oldValue = this.selection;
        this.selection = value;
        this._selectionChanged.next({
            selection: value,
            source,
            oldValue: oldValue,
        });
    }
    ngOnDestroy() {
        this._selectionChanged.complete();
    }
    _isValidDateInstance(date) {
        return (this._dateAdapter.isDateInstance(date) && this._dateAdapter.isValid(date));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsDateSelectionModel, deps: [{ token: i1.DateAdapter }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsDateSelectionModel }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsDateSelectionModel, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.DateAdapter }] });
export class RdsSingleDateSelectionModel extends RdsDateSelectionModel {
    constructor(adapter) {
        super(adapter);
        this.selection = null;
    }
    add(date) {
        super.updateSelection(date, this);
    }
    isValid() {
        return this.selection != null && this._isValidDateInstance(this.selection);
    }
    isComplete() {
        return this.selection != null;
    }
    clone() {
        const clone = new RdsSingleDateSelectionModel(this._dateAdapter);
        clone.updateSelection(this.selection, this);
        return clone;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsSingleDateSelectionModel, deps: [{ token: i1.DateAdapter }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsSingleDateSelectionModel }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsSingleDateSelectionModel, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.DateAdapter }] });
export class RdsRangeDateSelectionModel extends RdsDateSelectionModel {
    constructor(dateAdapter) {
        super(dateAdapter);
        this.selection = new DateRange(null, null);
    }
    add(date) {
        let { start, end } = this.selection;
        if (start == null) {
            start = date;
        }
        else if (end == null) {
            end = date;
        }
        else {
            start = date;
            end = null;
        }
        super.updateSelection(new DateRange(start, end), this);
    }
    isValid() {
        const { start, end } = this.selection;
        // Empty ranges are valid.
        if (start == null && end == null) {
            return true;
        }
        // Complete ranges are only valid if both dates are valid and the start is before the end.
        if (start != null && end != null) {
            return (this._isValidDateInstance(start) &&
                this._isValidDateInstance(end) &&
                this._dateAdapter.compareDate(start, end) <= 0);
        }
        // Partial ranges are valid if the start/end is valid.
        return ((start == null || this._isValidDateInstance(start)) &&
            (end == null || this._isValidDateInstance(end)));
    }
    isComplete() {
        return this.selection.start != null && this.selection.end != null;
    }
    clone() {
        const clone = new RdsRangeDateSelectionModel(this._dateAdapter);
        clone.updateSelection(this.selection, this);
        return clone;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsRangeDateSelectionModel, deps: [{ token: i1.DateAdapter }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsRangeDateSelectionModel }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsRangeDateSelectionModel, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.DateAdapter }] });
export function RDS_SINGLE_DATE_SELECTION_MODEL_FACTORY(parent, dateAdapter) {
    return parent || new RdsSingleDateSelectionModel(dateAdapter);
}
export const RDS_SINGLE_DATE_SELECTION_MODEL_PROVIDER = {
    provide: RdsDateSelectionModel,
    deps: [[new Optional(), new SkipSelf(), RdsDateSelectionModel], DateAdapter],
    useFactory: RDS_SINGLE_DATE_SELECTION_MODEL_FACTORY,
};
export function RDS_RANGE_DATE_SELECTION_MODEL_FACTORY(parent, dateAdapter) {
    return parent || new RdsRangeDateSelectionModel(dateAdapter);
}
export const RDS_RANGE_DATE_SELECTION_MODEL_PROVIDER = {
    provide: RdsDateSelectionModel,
    deps: [[new Optional(), new SkipSelf(), RdsDateSelectionModel], DateAdapter],
    useFactory: RDS_RANGE_DATE_SELECTION_MODEL_FACTORY,
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1zZWxlY3Rpb24ubW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL2FuZ3VsYXItY29tcG9uZW50cy9zcmMvbGliL2RhdGVwaWNrZXIvZGF0ZS1zZWxlY3Rpb24ubW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFVBQVUsRUFFVixRQUFRLEVBQ1IsUUFBUSxHQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDeEMsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQzs7O0FBRTNDLE1BQU0sT0FBTyxTQUFTO0lBR3BCLFlBQ1csS0FBZSxFQUNmLEdBQWE7UUFEYixVQUFLLEdBQUwsS0FBSyxDQUFVO1FBQ2YsUUFBRyxHQUFILEdBQUcsQ0FBVTtJQUNyQixDQUFDO0NBQ0w7QUFZRCxNQUFNLE9BQWdCLHFCQUFxQjtJQVd6QyxZQUF5QyxZQUE0QjtRQUE1QixpQkFBWSxHQUFaLFlBQVksQ0FBZ0I7UUFON0Qsc0JBQWlCLEdBQUcsSUFBSSxPQUFPLEVBQStCLENBQUM7UUFDaEUsY0FBUyxHQUFhLElBQUksQ0FBQztRQUVsQyxxQkFBZ0IsR0FDZCxJQUFJLENBQUMsaUJBQWlCLENBQUM7SUFFK0MsQ0FBQztJQUV6RSxlQUFlLENBQUMsS0FBUSxFQUFFLE1BQWU7UUFDdkMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDO1lBQzFCLFNBQVMsRUFBRSxLQUFLO1lBQ2hCLE1BQU07WUFDTixRQUFRLEVBQUUsUUFBYTtTQUN4QixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsQ0FB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QUFNLHVDQUF1QyxHQUFvQjtJQUN0RSxPQUFPLEVBQUUscUJBQXFCO0lBQzlCLElBQUksRUFBRSxDQUFDLENBQUMsSUFBSSxRQUFRLEVBQUUsRUFBRSxJQUFJLFFBQVEsRUFBRSxFQUFFLHFCQUFxQixDQUFDLEVBQUUsV0FBVyxDQUFDO0lBQzVFLFVBQVUsRUFBRSxzQ0FBc0M7Q0FDbkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEZhY3RvcnlQcm92aWRlcixcbiAgSW5qZWN0YWJsZSxcbiAgT25EZXN0cm95LFxuICBPcHRpb25hbCxcbiAgU2tpcFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgY2xhc3MgRGF0ZVJhbmdlPEQ+IHtcbiAgcHJpdmF0ZSBfZGlzYWJsZVN0cnVjdHVyYWxFcXVpdmFsZW5jeTogbmV2ZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc3RhcnQ6IEQgfCBudWxsLFxuICAgIHJlYWRvbmx5IGVuZDogRCB8IG51bGwsXG4gICkge31cbn1cblxuZXhwb3J0IHR5cGUgRXh0cmFjdERhdGVUeXBlRnJvbVNlbGVjdGlvbjxUPiA9XG4gIFQgZXh0ZW5kcyBEYXRlUmFuZ2U8aW5mZXIgRD4gPyBEIDogTm9uTnVsbGFibGU8VD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNlbGVjdGlvbk1vZGVsQ2hhbmdlPFM+IHtcbiAgc2VsZWN0aW9uOiBTO1xuICBzb3VyY2U6IHVua25vd247XG4gIG9sZFZhbHVlPzogUztcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFJkc0RhdGVTZWxlY3Rpb25Nb2RlbDxcbiAgUyxcbiAgRCA9IEV4dHJhY3REYXRlVHlwZUZyb21TZWxlY3Rpb248Uz4sXG4+IGltcGxlbWVudHMgT25EZXN0cm95XG57XG4gIHByaXZhdGUgX3NlbGVjdGlvbkNoYW5nZWQgPSBuZXcgU3ViamVjdDxEYXRlU2VsZWN0aW9uTW9kZWxDaGFuZ2U8Uz4+KCk7XG4gIHB1YmxpYyBzZWxlY3Rpb246IFMgfCBudWxsID0gbnVsbDtcblxuICBzZWxlY3Rpb25DaGFuZ2VkOiBPYnNlcnZhYmxlPERhdGVTZWxlY3Rpb25Nb2RlbENoYW5nZTxTPj4gPVxuICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQ7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBfZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPEQ+KSB7fVxuXG4gIHVwZGF0ZVNlbGVjdGlvbih2YWx1ZTogUywgc291cmNlOiB1bmtub3duKTogdm9pZCB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgIHRoaXMuX3NlbGVjdGlvbkNoYW5nZWQubmV4dCh7XG4gICAgICBzZWxlY3Rpb246IHZhbHVlLFxuICAgICAgc291cmNlLFxuICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlIGFzIFMsXG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25DaGFuZ2VkLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2lzVmFsaWREYXRlSW5zdGFuY2UoZGF0ZTogRCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9kYXRlQWRhcHRlci5pc0RhdGVJbnN0YW5jZShkYXRlKSAmJiB0aGlzLl9kYXRlQWRhcHRlci5pc1ZhbGlkKGRhdGUpXG4gICAgKTtcbiAgfVxuXG4gIGFic3RyYWN0IGFkZChkYXRlOiBEIHwgbnVsbCk6IHZvaWQ7XG5cbiAgYWJzdHJhY3QgaXNWYWxpZCgpOiBib29sZWFuO1xuXG4gIGFic3RyYWN0IGlzQ29tcGxldGUoKTogYm9vbGVhbjtcblxuICBhYnN0cmFjdCBjbG9uZSgpOiBSZHNEYXRlU2VsZWN0aW9uTW9kZWw8UywgRD47XG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZHNTaW5nbGVEYXRlU2VsZWN0aW9uTW9kZWw8RD4gZXh0ZW5kcyBSZHNEYXRlU2VsZWN0aW9uTW9kZWw8XG4gIEQgfCBudWxsLFxuICBEXG4+IHtcbiAgY29uc3RydWN0b3IoYWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4pIHtcbiAgICBzdXBlcihhZGFwdGVyKTtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XG4gIH1cblxuICBhZGQoZGF0ZTogRCB8IG51bGwpOiB2b2lkIHtcbiAgICBzdXBlci51cGRhdGVTZWxlY3Rpb24oZGF0ZSwgdGhpcyk7XG4gIH1cblxuICBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiAhPSBudWxsICYmIHRoaXMuX2lzVmFsaWREYXRlSW5zdGFuY2UodGhpcy5zZWxlY3Rpb24pO1xuICB9XG5cbiAgaXNDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gIT0gbnVsbDtcbiAgfVxuXG4gIGNsb25lKCk6IFJkc0RhdGVTZWxlY3Rpb25Nb2RlbDxEIHwgbnVsbCwgRD4ge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFJkc1NpbmdsZURhdGVTZWxlY3Rpb25Nb2RlbDxEPih0aGlzLl9kYXRlQWRhcHRlcik7XG4gICAgY2xvbmUudXBkYXRlU2VsZWN0aW9uKHRoaXMuc2VsZWN0aW9uLCB0aGlzKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUmRzUmFuZ2VEYXRlU2VsZWN0aW9uTW9kZWw8RD4gZXh0ZW5kcyBSZHNEYXRlU2VsZWN0aW9uTW9kZWw8XG4gIERhdGVSYW5nZTxEPixcbiAgRFxuPiB7XG4gIHB1YmxpYyBvdmVycmlkZSBzZWxlY3Rpb246IERhdGVSYW5nZTxEPjtcblxuICBjb25zdHJ1Y3RvcihkYXRlQWRhcHRlcjogRGF0ZUFkYXB0ZXI8RD4pIHtcbiAgICBzdXBlcihkYXRlQWRhcHRlcik7XG4gICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgRGF0ZVJhbmdlPEQ+KG51bGwsIG51bGwpO1xuICB9XG5cbiAgYWRkKGRhdGU6IEQgfCBudWxsKTogdm9pZCB7XG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5zZWxlY3Rpb247XG5cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSBkYXRlO1xuICAgIH0gZWxzZSBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gZGF0ZTtcbiAgICAgIGVuZCA9IG51bGw7XG4gICAgfVxuXG4gICAgc3VwZXIudXBkYXRlU2VsZWN0aW9uKG5ldyBEYXRlUmFuZ2U8RD4oc3RhcnQsIGVuZCksIHRoaXMpO1xuICB9XG5cbiAgaXNWYWxpZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgLy8gRW1wdHkgcmFuZ2VzIGFyZSB2YWxpZC5cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCAmJiBlbmQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ29tcGxldGUgcmFuZ2VzIGFyZSBvbmx5IHZhbGlkIGlmIGJvdGggZGF0ZXMgYXJlIHZhbGlkIGFuZCB0aGUgc3RhcnQgaXMgYmVmb3JlIHRoZSBlbmQuXG4gICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgZW5kICE9IG51bGwpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX2lzVmFsaWREYXRlSW5zdGFuY2Uoc3RhcnQpICYmXG4gICAgICAgIHRoaXMuX2lzVmFsaWREYXRlSW5zdGFuY2UoZW5kKSAmJlxuICAgICAgICB0aGlzLl9kYXRlQWRhcHRlci5jb21wYXJlRGF0ZShzdGFydCwgZW5kKSA8PSAwXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBhcnRpYWwgcmFuZ2VzIGFyZSB2YWxpZCBpZiB0aGUgc3RhcnQvZW5kIGlzIHZhbGlkLlxuICAgIHJldHVybiAoXG4gICAgICAoc3RhcnQgPT0gbnVsbCB8fCB0aGlzLl9pc1ZhbGlkRGF0ZUluc3RhbmNlKHN0YXJ0KSkgJiZcbiAgICAgIChlbmQgPT0gbnVsbCB8fCB0aGlzLl9pc1ZhbGlkRGF0ZUluc3RhbmNlKGVuZCkpXG4gICAgKTtcbiAgfVxuXG4gIGlzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICE9IG51bGwgJiYgdGhpcy5zZWxlY3Rpb24uZW5kICE9IG51bGw7XG4gIH1cblxuICBjbG9uZSgpOiBSZHNSYW5nZURhdGVTZWxlY3Rpb25Nb2RlbDxEPiB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgUmRzUmFuZ2VEYXRlU2VsZWN0aW9uTW9kZWw8RD4odGhpcy5fZGF0ZUFkYXB0ZXIpO1xuICAgIGNsb25lLnVwZGF0ZVNlbGVjdGlvbih0aGlzLnNlbGVjdGlvbiwgdGhpcyk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJEU19TSU5HTEVfREFURV9TRUxFQ1RJT05fTU9ERUxfRkFDVE9SWShcbiAgcGFyZW50OiBSZHNTaW5nbGVEYXRlU2VsZWN0aW9uTW9kZWw8dW5rbm93bj4sXG4gIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjx1bmtub3duPixcbik6IFJkc1NpbmdsZURhdGVTZWxlY3Rpb25Nb2RlbDx1bmtub3duPiB7XG4gIHJldHVybiBwYXJlbnQgfHwgbmV3IFJkc1NpbmdsZURhdGVTZWxlY3Rpb25Nb2RlbChkYXRlQWRhcHRlcik7XG59XG5cbmV4cG9ydCBjb25zdCBSRFNfU0lOR0xFX0RBVEVfU0VMRUNUSU9OX01PREVMX1BST1ZJREVSOiBGYWN0b3J5UHJvdmlkZXIgPSB7XG4gIHByb3ZpZGU6IFJkc0RhdGVTZWxlY3Rpb25Nb2RlbCxcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFJkc0RhdGVTZWxlY3Rpb25Nb2RlbF0sIERhdGVBZGFwdGVyXSxcbiAgdXNlRmFjdG9yeTogUkRTX1NJTkdMRV9EQVRFX1NFTEVDVElPTl9NT0RFTF9GQUNUT1JZLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIFJEU19SQU5HRV9EQVRFX1NFTEVDVElPTl9NT0RFTF9GQUNUT1JZKFxuICBwYXJlbnQ6IFJkc1NpbmdsZURhdGVTZWxlY3Rpb25Nb2RlbDx1bmtub3duPixcbiAgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPHVua25vd24+LFxuKTogUmRzU2luZ2xlRGF0ZVNlbGVjdGlvbk1vZGVsPHVua25vd24+IHtcbiAgcmV0dXJuIHBhcmVudCB8fCBuZXcgUmRzUmFuZ2VEYXRlU2VsZWN0aW9uTW9kZWwoZGF0ZUFkYXB0ZXIpO1xufVxuXG5leHBvcnQgY29uc3QgUkRTX1JBTkdFX0RBVEVfU0VMRUNUSU9OX01PREVMX1BST1ZJREVSOiBGYWN0b3J5UHJvdmlkZXIgPSB7XG4gIHByb3ZpZGU6IFJkc0RhdGVTZWxlY3Rpb25Nb2RlbCxcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFJkc0RhdGVTZWxlY3Rpb25Nb2RlbF0sIERhdGVBZGFwdGVyXSxcbiAgdXNlRmFjdG9yeTogUkRTX1JBTkdFX0RBVEVfU0VMRUNUSU9OX01PREVMX0ZBQ1RPUlksXG59O1xuIl19