import { ContentChildren, DestroyRef, Directive, ElementRef, EventEmitter, inject, Input, NgZone, numberAttribute, Output, QueryList, Renderer2, } from '@angular/core';
import { fromEvent } from 'rxjs';
import { RdsTableDragHandleDirective } from './table-drag-handle.directive';
import { filter, map, take, takeUntil } from 'rxjs/operators';
import { DOCUMENT } from '@angular/common';
import { cellsToRowsHTML, isElement, isInsideRect, } from './table-draggable.helpers';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
const HEADER_ROW_SELECTOR = '.rds-header-row';
const HEADER_CELL_SELECTOR = '.rds-header-cell';
export class RdsTableDraggableDirective {
    constructor() {
        this.destroyRef = inject(DestroyRef);
        this.document = inject(DOCUMENT);
        this.renderer = inject(Renderer2);
        this.originalTable = inject(ElementRef).nativeElement;
        this.zone = inject(NgZone);
        this.header = null;
        this.columnPreview = null;
        this.columnRects = [];
        this.maxPreviewRows = 10;
        this.rdsTableDragEnd = new EventEmitter();
    }
    ngAfterViewInit() {
        this.zone.runOutsideAngular(() => {
            this.createDragStartObservable().subscribe((e) => this.onDragStart(e));
        });
    }
    onDragStart({ draggedHeaderCell, nativeEvent, }) {
        this.columnRects = [];
        this.createAndInsertContainerElement();
        this.saveCoords(nativeEvent);
        this.getHeaderCells().forEach((headerCell, index) => this.createColumnAndHandleDrag(draggedHeaderCell, headerCell, index));
        this.createDragMoveObservable().subscribe((e) => this.onDragMove(e));
        this.createDragEndObservable().subscribe(() => this.onDragEnd());
    }
    createColumnAndHandleDrag(draggedHeaderCell, headerCell, index) {
        headerCell === draggedHeaderCell
            ? this.addDraggedColumn(headerCell, index)
            : this.addColumn(headerCell, index);
    }
    addColumn(headerCell, index) {
        const { width } = headerCell.getBoundingClientRect();
        const rowsHTML = cellsToRowsHTML(this.getColumnCells(index));
        this.container.innerHTML += this.createColumnHTML(rowsHTML, width, headerCell);
        this.saveLastColumnRect(index);
    }
    addDraggedColumn(headerCell, index) {
        this.currentIndex = index;
        this.originalIndex = index;
        const { width, x, y } = headerCell.getBoundingClientRect();
        const rowsHTML = cellsToRowsHTML(this.getColumnCells(index), this.maxPreviewRows);
        this.container.innerHTML += this.createColumnPlaceholderHTML(width, this.boundingRect.height);
        this.saveLastColumnRect(index);
        this.columnPreview = this.createColumnPreview(headerCell, width, rowsHTML);
        this.renderer.insertBefore(this.document.body, this.columnPreview, null);
        this.moveColumnAnimationFrame = requestAnimationFrame(this.followPointerFactory(x, y));
    }
    saveLastColumnRect(index) {
        this.columnRects[index] =
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.container.lastElementChild.getBoundingClientRect();
    }
    createDragStartObservable() {
        return fromEvent(this.originalTable, 'pointerdown').pipe(map((event) => this.addHeaderCellData(event)), filter(Boolean), takeUntilDestroyed(this.destroyRef));
    }
    createDragMoveObservable() {
        return fromEvent(this.document.body, 'pointermove').pipe(takeUntil(this.rdsTableDragEnd), takeUntilDestroyed(this.destroyRef));
    }
    addHeaderCellData(event) {
        if (!isElement(event.target)) {
            return null;
        }
        if (this.dragHandlesQuery.length &&
            !this.dragHandlesQuery.some((handle) => handle.nativeElement === event.target)) {
            return null;
        }
        // header is rebuilt after each drag end, so we need to query it on each drag start
        this.header = event.target.closest(HEADER_ROW_SELECTOR);
        if (!this.header) {
            return null;
        }
        const draggedHeaderCell = event.target.closest(HEADER_CELL_SELECTOR);
        if (!draggedHeaderCell) {
            return null;
        }
        return { draggedHeaderCell, nativeEvent: event };
    }
    createAndInsertContainerElement() {
        this.boundingRect = this.originalTable.getBoundingClientRect();
        this.container = this.renderer.createElement('div');
        this.renderer.addClass(this.container, 'rds-table-draggable-preview');
        this.renderer.setStyle(this.container, 'width', this.boundingRect.width + 'px');
        this.renderer.setStyle(this.container, 'height', this.boundingRect.height + 'px');
        this.renderer.insertBefore(this.originalTable.parentElement, this.container, this.originalTable);
    }
    getColumnCells(columnIndex) {
        return Array.from(this.originalTable.querySelectorAll(`.rds-cell:nth-child(${columnIndex + 1})`));
    }
    createColumnPreview(headerCell, width, rowsHTML) {
        const columnPreview = this.renderer.createElement('div');
        this.renderer.setStyle(columnPreview, 'position', 'fixed');
        this.renderer.setStyle(columnPreview, 'top', '0');
        this.renderer.setStyle(columnPreview, 'left', '0');
        this.renderer.setStyle(columnPreview, 'z-index', '99999999');
        const height = headerCell.parentElement?.offsetHeight;
        columnPreview.innerHTML = `
      <table class="${this.originalTable.classList.value}" style="width: ${width}px; ">
          <thead>
            <tr class="rds-row">
              <th class="rds-header-cell" style="height: ${height ? height + 'px' : 'unset'}">${headerCell.innerHTML}</th>
            </tr>
          </thead>
          <tbody>
            ${rowsHTML}
          </tbody>
      </table>
        `;
        return columnPreview;
    }
    createColumnHTML(rowsHTML, width, headerCell) {
        const height = headerCell.parentElement?.offsetHeight;
        return `
          <div style="flex-shrink: 0;">
            <table class="${this.originalTable.classList.value}" style="width: ${width}px;">
                <thead>
                  <tr class="rds-row">
                    <th class="rds-header-cell" style="height: ${height ? height + 'px' : 'unset'}">${headerCell.innerHTML}</th>
                  </tr>
                </thead>
                <tbody>
                  ${rowsHTML}
                </tbody>
            </table>
          </div>
        `;
    }
    createColumnPlaceholderHTML(width, height) {
        return `
      <div class="rds-table-draggable-column-placeholder" style="width: ${width}px; height: ${height}px"></div>
    `;
    }
    getHeaderCells() {
        return Array.from(this.header?.querySelectorAll(HEADER_CELL_SELECTOR) ?? []);
    }
    swapColumns(aIndex, bIndex) {
        const aColumn = this.container.children.item(aIndex);
        const bColumn = this.container.children.item(bIndex);
        if (!aColumn || !bColumn) {
            return;
        }
        if (bIndex > aIndex) {
            this.renderer.insertBefore(this.container, bColumn, aColumn);
        }
        else {
            this.renderer.insertBefore(this.container, aColumn, bColumn);
        }
    }
    createDragEndObservable() {
        return fromEvent(window, 'pointerup', { once: true }).pipe(take(1), takeUntilDestroyed(this.destroyRef));
    }
    onDragMove(event) {
        this.saveCoords(event);
        for (let i = 0; i < this.columnRects.length; i++) {
            if (i === this.currentIndex) {
                continue;
            }
            const rect = this.columnRects[i];
            if (isInsideRect(event, rect)) {
                this.swapColumns(this.currentIndex, i);
                this.currentIndex = i;
                break;
            }
        }
    }
    saveCoords({ clientX, clientY }) {
        this.clientX = clientX;
        this.clientY = clientY;
    }
    onDragEnd() {
        cancelAnimationFrame(this.moveColumnAnimationFrame);
        this.removeContainerAndPreview();
        this.emitChange();
    }
    emitChange() {
        this.zone.run(() => {
            this.rdsTableDragEnd.emit({
                oldIndex: this.originalIndex,
                newIndex: this.currentIndex,
            });
        });
    }
    removeContainerAndPreview() {
        this.renderer.removeChild(this.container.parentElement, this.container);
        if (this.columnPreview) {
            this.renderer.removeChild(this.document.body, this.columnPreview);
        }
    }
    followPointerFactory(columnOriginX, columnOriginY) {
        const offsetX = this.clientX - columnOriginX;
        const offsetY = this.clientY - columnOriginY;
        const followPointer = () => {
            this.renderer.setStyle(this.columnPreview, 'transform', `translate(${this.clientX - offsetX}px, ${this.clientY - offsetY}px)`);
            this.moveColumnAnimationFrame = requestAnimationFrame(followPointer);
        };
        return followPointer;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsTableDraggableDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "17.3.1", type: RdsTableDraggableDirective, selector: "[rdsTableDraggable], [rds-table-draggable]", inputs: { maxPreviewRows: ["maxPreviewRows", "maxPreviewRows", numberAttribute] }, outputs: { rdsTableDragEnd: "rdsTableDragEnd" }, queries: [{ propertyName: "dragHandlesQuery", predicate: RdsTableDragHandleDirective, descendants: true }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsTableDraggableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[rdsTableDraggable], [rds-table-draggable]',
                }]
        }], propDecorators: { dragHandlesQuery: [{
                type: ContentChildren,
                args: [RdsTableDragHandleDirective, { descendants: true }]
            }], maxPreviewRows: [{
                type: Input,
                args: [{ transform: numberAttribute }]
            }], rdsTableDragEnd: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtZHJhZ2dhYmxlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvYW5ndWxhci1jb21wb25lbnRzL3NyYy9saWIvdGFibGUvdGFibGUtZHJhZ2dhYmxlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsZUFBZSxFQUNmLFVBQVUsRUFDVixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLE1BQU0sRUFDTixlQUFlLEVBQ2YsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUM3QyxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM1RSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFDTCxlQUFlLEVBQ2YsU0FBUyxFQUNULFlBQVksR0FDYixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUVoRSxNQUFNLG1CQUFtQixHQUFHLGlCQUFpQixDQUFDO0FBQzlDLE1BQU0sb0JBQW9CLEdBQUcsa0JBQWtCLENBQUM7QUFlaEQsTUFBTSxPQUFPLDBCQUEwQjtJQUh2QztRQUltQixlQUFVLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hDLGFBQVEsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDNUIsYUFBUSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM3QixrQkFBYSxHQUM1QixNQUFNLENBQTBC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QUFHLEdBQVMsRUFBRTtZQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FDcEIsSUFBSSxDQUFDLGFBQWEsRUFDbEIsV0FBVyxFQUNYLGFBQWEsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLEtBQUssQ0FDdEUsQ0FBQztZQUVGLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxxQkFBcUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN2RSxDQUFDLENBQUM7UUFFRixPQUFPLGFBQWEsQ0FBQztJQUN2QixDQUFDOzhHQWpWVSwwQkFBMEI7a0dBQTFCLDBCQUEwQix5SEFzQmpCLGVBQWUsK0dBSGxCLDJCQUEyQjs7MkZBbkJqQywwQkFBMEI7a0JBSHRDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDRDQUE0QztpQkFDdkQ7OEJBcUJDLGdCQUFnQjtzQkFEZixlQUFlO3VCQUFDLDJCQUEyQixFQUFFLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRTtnQkFHNUIsY0FBYztzQkFBcEQsS0FBSzt1QkFBQyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUU7Z0JBR3JDLGVBQWU7c0JBRGQsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGVzdHJveVJlZixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIGluamVjdCxcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgbnVtYmVyQXR0cmlidXRlLFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUmRzVGFibGVEcmFnSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJsZS1kcmFnLWhhbmRsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2UsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFBvaW50ZXJFdmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIGNlbGxzVG9Sb3dzSFRNTCxcbiAgaXNFbGVtZW50LFxuICBpc0luc2lkZVJlY3QsXG59IGZyb20gJy4vdGFibGUtZHJhZ2dhYmxlLmhlbHBlcnMnO1xuaW1wb3J0IHsgdGFrZVVudGlsRGVzdHJveWVkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZS9yeGpzLWludGVyb3AnO1xuXG5jb25zdCBIRUFERVJfUk9XX1NFTEVDVE9SID0gJy5yZHMtaGVhZGVyLXJvdyc7XG5jb25zdCBIRUFERVJfQ0VMTF9TRUxFQ1RPUiA9ICcucmRzLWhlYWRlci1jZWxsJztcblxuZXhwb3J0IHR5cGUgUmRzVGFibGVEcmFnRW5kRXZlbnQgPSB7XG4gIG9sZEluZGV4OiBudW1iZXI7XG4gIG5ld0luZGV4OiBudW1iZXI7XG59O1xuXG50eXBlIFJkc1RhYmxlRHJhZ1N0YXJ0RXZlbnQgPSB7XG4gIG5hdGl2ZUV2ZW50OiBQb2ludGVyRXZlbnQ8RWxlbWVudD47XG4gIGRyYWdnZWRIZWFkZXJDZWxsOiBFbGVtZW50O1xufTtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3Jkc1RhYmxlRHJhZ2dhYmxlXSwgW3Jkcy10YWJsZS1kcmFnZ2FibGVdJyxcbn0pXG5leHBvcnQgY2xhc3MgUmRzVGFibGVEcmFnZ2FibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBkZXN0cm95UmVmID0gaW5qZWN0KERlc3Ryb3lSZWYpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRvY3VtZW50ID0gaW5qZWN0KERPQ1VNRU5UKTtcbiAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJlciA9IGluamVjdChSZW5kZXJlcjIpO1xuICBwcml2YXRlIHJlYWRvbmx5IG9yaWdpbmFsVGFibGUgPVxuICAgIGluamVjdDxFbGVtZW50UmVmPEhUTUxFbGVtZW50Pj4oRWxlbWVudFJlZikubmF0aXZlRWxlbWVudDtcbiAgcHJpdmF0ZSByZWFkb25seSB6b25lID0gaW5qZWN0KE5nWm9uZSk7XG5cbiAgcHJpdmF0ZSBoZWFkZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY29udGFpbmVyOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBib3VuZGluZ1JlY3Q6IERPTVJlY3Q7XG4gIHByaXZhdGUgY29sdW1uUHJldmlldzogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50SW5kZXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBvcmlnaW5hbEluZGV4OiBudW1iZXI7XG4gIHByaXZhdGUgY2xpZW50WDogbnVtYmVyO1xuICBwcml2YXRlIGNsaWVudFk6IG51bWJlcjtcbiAgcHJpdmF0ZSBjb2x1bW5SZWN0czogRE9NUmVjdFtdID0gW107XG4gIHByaXZhdGUgbW92ZUNvbHVtbkFuaW1hdGlvbkZyYW1lOiBudW1iZXI7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihSZHNUYWJsZURyYWdIYW5kbGVEaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgZHJhZ0hhbmRsZXNRdWVyeTogUXVlcnlMaXN0PFJkc1RhYmxlRHJhZ0hhbmRsZURpcmVjdGl2ZT47XG5cbiAgQElucHV0KHsgdHJhbnNmb3JtOiBudW1iZXJBdHRyaWJ1dGUgfSkgbWF4UHJldmlld1Jvd3MgPSAxMDtcblxuICBAT3V0cHV0KClcbiAgcmRzVGFibGVEcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxSZHNUYWJsZURyYWdFbmRFdmVudD4oKTtcblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIHRoaXMuY3JlYXRlRHJhZ1N0YXJ0T2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgoZSkgPT4gdGhpcy5vbkRyYWdTdGFydChlKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ1N0YXJ0KHtcbiAgICBkcmFnZ2VkSGVhZGVyQ2VsbCxcbiAgICBuYXRpdmVFdmVudCxcbiAgfTogUmRzVGFibGVEcmFnU3RhcnRFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuY29sdW1uUmVjdHMgPSBbXTtcbiAgICB0aGlzLmNyZWF0ZUFuZEluc2VydENvbnRhaW5lckVsZW1lbnQoKTtcbiAgICB0aGlzLnNhdmVDb29yZHMobmF0aXZlRXZlbnQpO1xuICAgIHRoaXMuZ2V0SGVhZGVyQ2VsbHMoKS5mb3JFYWNoKChoZWFkZXJDZWxsLCBpbmRleCkgPT5cbiAgICAgIHRoaXMuY3JlYXRlQ29sdW1uQW5kSGFuZGxlRHJhZyhkcmFnZ2VkSGVhZGVyQ2VsbCwgaGVhZGVyQ2VsbCwgaW5kZXgpLFxuICAgICk7XG4gICAgdGhpcy5jcmVhdGVEcmFnTW92ZU9ic2VydmFibGUoKS5zdWJzY3JpYmUoKGUpID0+IHRoaXMub25EcmFnTW92ZShlKSk7XG4gICAgdGhpcy5jcmVhdGVEcmFnRW5kT2JzZXJ2YWJsZSgpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uRHJhZ0VuZCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ29sdW1uQW5kSGFuZGxlRHJhZyhcbiAgICBkcmFnZ2VkSGVhZGVyQ2VsbDogRWxlbWVudCxcbiAgICBoZWFkZXJDZWxsOiBFbGVtZW50LFxuICAgIGluZGV4OiBudW1iZXIsXG4gICk6IHZvaWQge1xuICAgIGhlYWRlckNlbGwgPT09IGRyYWdnZWRIZWFkZXJDZWxsXG4gICAgICA/IHRoaXMuYWRkRHJhZ2dlZENvbHVtbihoZWFkZXJDZWxsLCBpbmRleClcbiAgICAgIDogdGhpcy5hZGRDb2x1bW4oaGVhZGVyQ2VsbCwgaW5kZXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRDb2x1bW4oaGVhZGVyQ2VsbDogRWxlbWVudCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgd2lkdGggfSA9IGhlYWRlckNlbGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgcm93c0hUTUwgPSBjZWxsc1RvUm93c0hUTUwodGhpcy5nZXRDb2x1bW5DZWxscyhpbmRleCkpO1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCArPSB0aGlzLmNyZWF0ZUNvbHVtbkhUTUwoXG4gICAgICByb3dzSFRNTCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVhZGVyQ2VsbCxcbiAgICApO1xuXG4gICAgdGhpcy5zYXZlTGFzdENvbHVtblJlY3QoaW5kZXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGREcmFnZ2VkQ29sdW1uKGhlYWRlckNlbGw6IEVsZW1lbnQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgIHRoaXMub3JpZ2luYWxJbmRleCA9IGluZGV4O1xuXG4gICAgY29uc3QgeyB3aWR0aCwgeCwgeSB9ID0gaGVhZGVyQ2VsbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCByb3dzSFRNTCA9IGNlbGxzVG9Sb3dzSFRNTChcbiAgICAgIHRoaXMuZ2V0Q29sdW1uQ2VsbHMoaW5kZXgpLFxuICAgICAgdGhpcy5tYXhQcmV2aWV3Um93cyxcbiAgICApO1xuXG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MICs9IHRoaXMuY3JlYXRlQ29sdW1uUGxhY2Vob2xkZXJIVE1MKFxuICAgICAgd2lkdGgsXG4gICAgICB0aGlzLmJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgKTtcblxuICAgIHRoaXMuc2F2ZUxhc3RDb2x1bW5SZWN0KGluZGV4KTtcblxuICAgIHRoaXMuY29sdW1uUHJldmlldyA9IHRoaXMuY3JlYXRlQ29sdW1uUHJldmlldyhoZWFkZXJDZWxsLCB3aWR0aCwgcm93c0hUTUwpO1xuICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy5jb2x1bW5QcmV2aWV3LCBudWxsKTtcblxuICAgIHRoaXMubW92ZUNvbHVtbkFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgdGhpcy5mb2xsb3dQb2ludGVyRmFjdG9yeSh4LCB5KSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlTGFzdENvbHVtblJlY3QoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY29sdW1uUmVjdHNbaW5kZXhdID1cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICB0aGlzLmNvbnRhaW5lci5sYXN0RWxlbWVudENoaWxkIS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRHJhZ1N0YXJ0T2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPFJkc1RhYmxlRHJhZ1N0YXJ0RXZlbnQ+IHtcbiAgICByZXR1cm4gZnJvbUV2ZW50PFBvaW50ZXJFdmVudD4odGhpcy5vcmlnaW5hbFRhYmxlLCAncG9pbnRlcmRvd24nKS5waXBlKFxuICAgICAgbWFwKChldmVudCkgPT4gdGhpcy5hZGRIZWFkZXJDZWxsRGF0YShldmVudCkpLFxuICAgICAgZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRHJhZ01vdmVPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PEVsZW1lbnQ+PiB7XG4gICAgcmV0dXJuIGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHRoaXMuZG9jdW1lbnQuYm9keSwgJ3BvaW50ZXJtb3ZlJykucGlwZShcbiAgICAgIHRha2VVbnRpbCh0aGlzLnJkc1RhYmxlRHJhZ0VuZCksXG4gICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy5kZXN0cm95UmVmKSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRIZWFkZXJDZWxsRGF0YShcbiAgICBldmVudDogUG9pbnRlckV2ZW50PEVsZW1lbnQ+LFxuICApOiBSZHNUYWJsZURyYWdTdGFydEV2ZW50IHwgbnVsbCB7XG4gICAgaWYgKCFpc0VsZW1lbnQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5kcmFnSGFuZGxlc1F1ZXJ5Lmxlbmd0aCAmJlxuICAgICAgIXRoaXMuZHJhZ0hhbmRsZXNRdWVyeS5zb21lKFxuICAgICAgICAoaGFuZGxlKSA9PiBoYW5kbGUubmF0aXZlRWxlbWVudCA9PT0gZXZlbnQudGFyZ2V0LFxuICAgICAgKVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gaGVhZGVyIGlzIHJlYnVpbHQgYWZ0ZXIgZWFjaCBkcmFnIGVuZCwgc28gd2UgbmVlZCB0byBxdWVyeSBpdCBvbiBlYWNoIGRyYWcgc3RhcnRcbiAgICB0aGlzLmhlYWRlciA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KEhFQURFUl9ST1dfU0VMRUNUT1IpO1xuXG4gICAgaWYgKCF0aGlzLmhlYWRlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZHJhZ2dlZEhlYWRlckNlbGwgPSBldmVudC50YXJnZXQuY2xvc2VzdChIRUFERVJfQ0VMTF9TRUxFQ1RPUik7XG5cbiAgICBpZiAoIWRyYWdnZWRIZWFkZXJDZWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4geyBkcmFnZ2VkSGVhZGVyQ2VsbCwgbmF0aXZlRXZlbnQ6IGV2ZW50IH07XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUFuZEluc2VydENvbnRhaW5lckVsZW1lbnQoKTogdm9pZCB7XG4gICAgdGhpcy5ib3VuZGluZ1JlY3QgPSB0aGlzLm9yaWdpbmFsVGFibGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnZGl2JykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgJ3Jkcy10YWJsZS1kcmFnZ2FibGUtcHJldmlldycpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICB0aGlzLmNvbnRhaW5lcixcbiAgICAgICd3aWR0aCcsXG4gICAgICB0aGlzLmJvdW5kaW5nUmVjdC53aWR0aCArICdweCcsXG4gICAgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICAnaGVpZ2h0JyxcbiAgICAgIHRoaXMuYm91bmRpbmdSZWN0LmhlaWdodCArICdweCcsXG4gICAgKTtcblxuICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKFxuICAgICAgdGhpcy5vcmlnaW5hbFRhYmxlLnBhcmVudEVsZW1lbnQsXG4gICAgICB0aGlzLmNvbnRhaW5lcixcbiAgICAgIHRoaXMub3JpZ2luYWxUYWJsZSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2x1bW5DZWxscyhjb2x1bW5JbmRleDogbnVtYmVyKTogRWxlbWVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIHRoaXMub3JpZ2luYWxUYWJsZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgLnJkcy1jZWxsOm50aC1jaGlsZCgke2NvbHVtbkluZGV4ICsgMX0pYCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ29sdW1uUHJldmlldyhcbiAgICBoZWFkZXJDZWxsOiBFbGVtZW50LFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgcm93c0hUTUw6IHN0cmluZyxcbiAgKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGNvbHVtblByZXZpZXcgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2RpdicpIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoY29sdW1uUHJldmlldywgJ3Bvc2l0aW9uJywgJ2ZpeGVkJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShjb2x1bW5QcmV2aWV3LCAndG9wJywgJzAnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNvbHVtblByZXZpZXcsICdsZWZ0JywgJzAnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGNvbHVtblByZXZpZXcsICd6LWluZGV4JywgJzk5OTk5OTk5Jyk7XG5cbiAgICBjb25zdCBoZWlnaHQgPSBoZWFkZXJDZWxsLnBhcmVudEVsZW1lbnQ/Lm9mZnNldEhlaWdodDtcblxuICAgIGNvbHVtblByZXZpZXcuaW5uZXJIVE1MID0gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFRhYmxlLmNsYXNzTGlzdC52YWx1ZVxuICAgICAgfVwiIHN0eWxlPVwid2lkdGg6ICR7d2lkdGh9cHg7IFwiPlxuICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgIDx0ciBjbGFzcz1cInJkcy1yb3dcIj5cbiAgICAgICAgICAgICAgPHRoIGNsYXNzPVwicmRzLWhlYWRlci1jZWxsXCIgc3R5bGU9XCJoZWlnaHQ6ICR7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID8gaGVpZ2h0ICsgJ3B4JyA6ICd1bnNldCdcbiAgICAgICAgICAgICAgfVwiPiR7aGVhZGVyQ2VsbC5pbm5lckhUTUx9PC90aD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAke3Jvd3NIVE1MfVxuICAgICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgICAgICBgO1xuXG4gICAgcmV0dXJuIGNvbHVtblByZXZpZXc7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUNvbHVtbkhUTUwoXG4gICAgcm93c0hUTUw6IHN0cmluZyxcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlYWRlckNlbGw6IEVsZW1lbnQsXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgaGVpZ2h0ID0gaGVhZGVyQ2VsbC5wYXJlbnRFbGVtZW50Py5vZmZzZXRIZWlnaHQ7XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgIDxkaXYgc3R5bGU9XCJmbGV4LXNocmluazogMDtcIj5cbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cIiR7XG4gICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxUYWJsZS5jbGFzc0xpc3QudmFsdWVcbiAgICAgICAgICAgIH1cIiBzdHlsZT1cIndpZHRoOiAke3dpZHRofXB4O1wiPlxuICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cInJkcy1yb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwicmRzLWhlYWRlci1jZWxsXCIgc3R5bGU9XCJoZWlnaHQ6ICR7XG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID8gaGVpZ2h0ICsgJ3B4JyA6ICd1bnNldCdcbiAgICAgICAgICAgICAgICAgICAgfVwiPiR7aGVhZGVyQ2VsbC5pbm5lckhUTUx9PC90aD5cbiAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAke3Jvd3NIVE1MfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDb2x1bW5QbGFjZWhvbGRlckhUTUwod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwicmRzLXRhYmxlLWRyYWdnYWJsZS1jb2x1bW4tcGxhY2Vob2xkZXJcIiBzdHlsZT1cIndpZHRoOiAke3dpZHRofXB4OyBoZWlnaHQ6ICR7aGVpZ2h0fXB4XCI+PC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0SGVhZGVyQ2VsbHMoKTogRWxlbWVudFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgIHRoaXMuaGVhZGVyPy5xdWVyeVNlbGVjdG9yQWxsKEhFQURFUl9DRUxMX1NFTEVDVE9SKSA/PyBbXSxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzd2FwQ29sdW1ucyhhSW5kZXg6IG51bWJlciwgYkluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBhQ29sdW1uID0gdGhpcy5jb250YWluZXIuY2hpbGRyZW4uaXRlbShhSW5kZXgpO1xuICAgIGNvbnN0IGJDb2x1bW4gPSB0aGlzLmNvbnRhaW5lci5jaGlsZHJlbi5pdGVtKGJJbmRleCk7XG5cbiAgICBpZiAoIWFDb2x1bW4gfHwgIWJDb2x1bW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYkluZGV4ID4gYUluZGV4KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmluc2VydEJlZm9yZSh0aGlzLmNvbnRhaW5lciwgYkNvbHVtbiwgYUNvbHVtbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHRoaXMuY29udGFpbmVyLCBhQ29sdW1uLCBiQ29sdW1uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURyYWdFbmRPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8UG9pbnRlckV2ZW50PiB7XG4gICAgcmV0dXJuIGZyb21FdmVudDxQb2ludGVyRXZlbnQ+KHdpbmRvdywgJ3BvaW50ZXJ1cCcsIHsgb25jZTogdHJ1ZSB9KS5waXBlKFxuICAgICAgdGFrZSgxKSxcbiAgICAgIHRha2VVbnRpbERlc3Ryb3llZCh0aGlzLmRlc3Ryb3lSZWYpLFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ01vdmUoZXZlbnQ6IFBvaW50ZXJFdmVudDxFbGVtZW50Pik6IHZvaWQge1xuICAgIHRoaXMuc2F2ZUNvb3JkcyhldmVudCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29sdW1uUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID09PSB0aGlzLmN1cnJlbnRJbmRleCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IHRoaXMuY29sdW1uUmVjdHNbaV07XG5cbiAgICAgIGlmIChpc0luc2lkZVJlY3QoZXZlbnQsIHJlY3QpKSB7XG4gICAgICAgIHRoaXMuc3dhcENvbHVtbnModGhpcy5jdXJyZW50SW5kZXgsIGkpO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzYXZlQ29vcmRzKHsgY2xpZW50WCwgY2xpZW50WSB9OiBQb2ludGVyRXZlbnQ8RWxlbWVudD4pOiB2b2lkIHtcbiAgICB0aGlzLmNsaWVudFggPSBjbGllbnRYO1xuICAgIHRoaXMuY2xpZW50WSA9IGNsaWVudFk7XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ0VuZCgpOiB2b2lkIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1vdmVDb2x1bW5BbmltYXRpb25GcmFtZSk7XG4gICAgdGhpcy5yZW1vdmVDb250YWluZXJBbmRQcmV2aWV3KCk7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cblxuICBwcml2YXRlIGVtaXRDaGFuZ2UoKTogdm9pZCB7XG4gICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICB0aGlzLnJkc1RhYmxlRHJhZ0VuZC5lbWl0KHtcbiAgICAgICAgb2xkSW5kZXg6IHRoaXMub3JpZ2luYWxJbmRleCxcbiAgICAgICAgbmV3SW5kZXg6IHRoaXMuY3VycmVudEluZGV4LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZUNvbnRhaW5lckFuZFByZXZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lci5wYXJlbnRFbGVtZW50LCB0aGlzLmNvbnRhaW5lcik7XG5cbiAgICBpZiAodGhpcy5jb2x1bW5QcmV2aWV3KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy5jb2x1bW5QcmV2aWV3KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGZvbGxvd1BvaW50ZXJGYWN0b3J5KFxuICAgIGNvbHVtbk9yaWdpblg6IG51bWJlcixcbiAgICBjb2x1bW5PcmlnaW5ZOiBudW1iZXIsXG4gICk6ICgpID0+IHZvaWQge1xuICAgIGNvbnN0IG9mZnNldFggPSB0aGlzLmNsaWVudFggLSBjb2x1bW5PcmlnaW5YO1xuICAgIGNvbnN0IG9mZnNldFkgPSB0aGlzLmNsaWVudFkgLSBjb2x1bW5PcmlnaW5ZO1xuXG4gICAgY29uc3QgZm9sbG93UG9pbnRlciA9ICgpOiB2b2lkID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgIHRoaXMuY29sdW1uUHJldmlldyxcbiAgICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAgIGB0cmFuc2xhdGUoJHt0aGlzLmNsaWVudFggLSBvZmZzZXRYfXB4LCAke3RoaXMuY2xpZW50WSAtIG9mZnNldFl9cHgpYCxcbiAgICAgICk7XG5cbiAgICAgIHRoaXMubW92ZUNvbHVtbkFuaW1hdGlvbkZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvbGxvd1BvaW50ZXIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZm9sbG93UG9pbnRlcjtcbiAgfVxufVxuIl19