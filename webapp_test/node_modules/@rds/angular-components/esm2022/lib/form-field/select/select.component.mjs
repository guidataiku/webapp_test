import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, END, ENTER, hasModifierKey, HOME, LEFT_ARROW, RIGHT_ARROW, SPACE, UP_ARROW, } from '@angular/cdk/keycodes';
import { ChangeDetectionStrategy, Component, Input, ViewEncapsulation, } from '@angular/core';
import { merge } from 'rxjs';
import { debounceTime, takeUntil } from 'rxjs/operators';
import { RdsAbstractFormFieldControl } from '../abstract-form-field-control';
import { SelectAnimations } from './select.animations';
import { RdsAbstractSelectComponent } from './abstract-select.component';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./trigger-values.component";
export class RdsSelectComponent extends RdsAbstractSelectComponent {
    constructor() {
        super(...arguments);
        this._name = 'rds-select';
    }
    set multiple(_multiple) {
        throw new Error(`Input 'multiple' is not valid anymore and will be removed in the next release. Use 'rds-multi-select' component instead.`);
    }
    get selected() {
        return this.selectionModel.selected[0];
    }
    get triggerValues() {
        if (this.empty) {
            return [''];
        }
        return [this.selectionModel.selected[0].viewValue];
    }
    ngOnInit() {
        super.ngOnInit();
        this.selectionModel = new SelectionModel(false);
    }
    handleClosedKeydown(event) {
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === DOWN_ARROW ||
            keyCode === UP_ARROW ||
            keyCode === LEFT_ARROW ||
            keyCode === RIGHT_ARROW;
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        const manager = this.keyManager;
        // Open the select on ALT + arrow key to match the native <select>
        if ((!manager.isTyping() && isOpenKey && !hasModifierKey(event)) ||
            (event.altKey && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.open();
        }
        else {
            const previouslySelectedOption = this.selected;
            if (keyCode === HOME || keyCode === END) {
                keyCode === HOME
                    ? manager.setFirstItemActive()
                    : manager.setLastItemActive();
                event.preventDefault();
            }
            else {
                manager.onKeydown(event);
            }
            const selectedOption = this.selected;
            if (selectedOption && previouslySelectedOption !== selectedOption) {
                this.liveAnnouncer.announce(selectedOption.viewValue, 10000);
            }
        }
    }
    handleOpenKeydown(event) {
        const manager = this.keyManager;
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        const isTyping = manager.isTyping();
        if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.close();
            // Don't do anything in this case if the user is typing,
            // because the typing sequence can include the space key.
        }
        else if (!isTyping &&
            (keyCode === ENTER || keyCode === SPACE) &&
            manager.activeItem &&
            !hasModifierKey(event)) {
            event.preventDefault();
            manager.activeItem.handleClick();
        }
        else {
            manager.onKeydown(event);
        }
    }
    setSelectionByValue(value) {
        this.selectionModel.clear();
        const correspondingOption = this.selectValue(value);
        // Shift focus to the active item. Note that we shouldn't do this in multiple
        // mode, because we don't know what option the user interacted with last.
        if (correspondingOption) {
            this.keyManager.updateActiveItem(correspondingOption);
        }
        else if (!this.panelOpen) {
            // Otherwise reset the highlighted option. Note that we only want to do this while
            // closed, because doing it while open can shift the user's focus unnecessarily.
            this.keyManager.updateActiveItem(-1);
        }
        this.cdr.markForCheck();
    }
    initKeyManager() {
        super.initKeyManager();
        this.keyManager.tabOut
            .pipe(takeUntil(this.destroyKeyManager$), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => {
            if (this.panelOpen) {
                // Select the active item when tabbing away. This is consistent with how the native
                // select behaves. Note that we only want to do this in single selection mode.
                if (this.keyManager.activeItem) {
                    this.keyManager.activeItem.toggle();
                }
            }
        });
        this.keyManager.change
            .pipe(takeUntil(this.destroyKeyManager$), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => {
            if (!this._panelOpen && this.keyManager.activeItem) {
                this.keyManager.activeItem.toggle();
            }
        });
    }
    resetOptions() {
        super.resetOptions();
        this.optionSelectionChanges
            .pipe(takeUntil(this.options.changes), takeUntilDestroyed(this.destroyRef))
            .subscribe((event) => {
            this.onSelect(event.source, event.isUserInput);
            if (event.isUserInput && this._panelOpen) {
                this.close();
                this.focus();
            }
        });
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.options.map((option) => option.checkedChanged))
            .pipe(
        // should emit one time if states changes for many options
        debounceTime(1), takeUntil(this.options.changes), takeUntilDestroyed(this.destroyRef))
            .subscribe(() => {
            this.stateChanges.next();
        });
    }
    onSelect(option, isUserInput = false) {
        super.onSelect(option);
        if (isUserInput) {
            this.keyManager.setActiveItem(option);
        }
        this.stateChanges.next();
    }
    getValueToEmit() {
        return this.selected ? this.selected.value : null;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsSelectComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.1", type: RdsSelectComponent, selector: "rds-select", inputs: { multiple: "multiple" }, providers: [
            { provide: RdsAbstractFormFieldControl, useExisting: RdsSelectComponent },
        ], usesInheritance: true, ngImport: i0, template: `
    <ng-container aria-hidden="true" (click)="toggle()">
      @if (shouldShowValue()) {
        <div class="rds-form-field__select-value" #wrapperElement>
          <span
            class="rds-form-field__select-trigger-value"
            rds-trigger-values
            #rdsTriggerValues="rdsTriggerValues"
            [triggerValues]="triggerValues"
            [wrapperElement]="wrapperElement"
          ></span>
        </div>
      } @else {
        @if (shouldShowPlaceholder()) {
          <div class="rds-form-field__select-value">
            <div
              class="rds-form-field__select-trigger-value rds-form-field__select-trigger-value-placeholder"
            >
              {{ placeholder }}
            </div>
          </div>
        }
      }

      <div class="rds-form-field__select-arrow-wrapper">
        <div
          class="rds-form-field__select-arrow"
          [class.rds-form-field__select-arrow--rotate]="panelOpen"
        ></div>
      </div>

      <ng-template
        cdk-connected-overlay
        cdkConnectedOverlayLockPosition
        cdkConnectedOverlayHasBackdrop
        cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
        [cdkConnectedOverlayScrollStrategy]="scrollStrategy"
        [cdkConnectedOverlayOrigin]="origin"
        [cdkConnectedOverlayOpen]="panelOpen"
        [cdkConnectedOverlayPositions]="positions"
        [cdkConnectedOverlayMinWidth]="minWidth"
        (backdropClick)="close(); onBlur()"
        (attach)="onAttached()"
        (detach)="close()"
      >
        <div class="rds-select__panel-wrapper" [@transformPanelWrap]="null">
          <div
            #panel
            class="rds-select__panel"
            [attr.id]="id + '-panel'"
            [@transformPanel]="'showing'"
            (@transformPanel.done)="
              panelDoneAnimatingStream.next($event.toState)
            "
            [style.transformOrigin]="transformOrigin"
            (keydown)="handleKeydown($event)"
          >
            <ng-content select="rds-select-search-input" />
            <ng-content select="rds-select-option" />
          </div>
        </div>
      </ng-template>
    </ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: i1.CdkConnectedOverlay, selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", inputs: ["cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPositionStrategy", "cdkConnectedOverlayOffsetX", "cdkConnectedOverlayOffsetY", "cdkConnectedOverlayWidth", "cdkConnectedOverlayHeight", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayMinHeight", "cdkConnectedOverlayBackdropClass", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayViewportMargin", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOpen", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayLockPosition", "cdkConnectedOverlayFlexibleDimensions", "cdkConnectedOverlayGrowAfterOpen", "cdkConnectedOverlayPush", "cdkConnectedOverlayDisposeOnNavigation"], outputs: ["backdropClick", "positionChange", "attach", "detach", "overlayKeydown", "overlayOutsideClick"], exportAs: ["cdkConnectedOverlay"] }, { kind: "component", type: i2.RdsTriggerValuesComponent, selector: "[rds-trigger-values]", inputs: ["triggerValues", "wrapperElement", "multiple"], outputs: ["hiddenValues"], exportAs: ["rdsTriggerValues"] }], animations: SelectAnimations, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.1", ngImport: i0, type: RdsSelectComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'rds-select',
                    template: `
    <ng-container aria-hidden="true" (click)="toggle()">
      @if (shouldShowValue()) {
        <div class="rds-form-field__select-value" #wrapperElement>
          <span
            class="rds-form-field__select-trigger-value"
            rds-trigger-values
            #rdsTriggerValues="rdsTriggerValues"
            [triggerValues]="triggerValues"
            [wrapperElement]="wrapperElement"
          ></span>
        </div>
      } @else {
        @if (shouldShowPlaceholder()) {
          <div class="rds-form-field__select-value">
            <div
              class="rds-form-field__select-trigger-value rds-form-field__select-trigger-value-placeholder"
            >
              {{ placeholder }}
            </div>
          </div>
        }
      }

      <div class="rds-form-field__select-arrow-wrapper">
        <div
          class="rds-form-field__select-arrow"
          [class.rds-form-field__select-arrow--rotate]="panelOpen"
        ></div>
      </div>

      <ng-template
        cdk-connected-overlay
        cdkConnectedOverlayLockPosition
        cdkConnectedOverlayHasBackdrop
        cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
        [cdkConnectedOverlayScrollStrategy]="scrollStrategy"
        [cdkConnectedOverlayOrigin]="origin"
        [cdkConnectedOverlayOpen]="panelOpen"
        [cdkConnectedOverlayPositions]="positions"
        [cdkConnectedOverlayMinWidth]="minWidth"
        (backdropClick)="close(); onBlur()"
        (attach)="onAttached()"
        (detach)="close()"
      >
        <div class="rds-select__panel-wrapper" [@transformPanelWrap]="null">
          <div
            #panel
            class="rds-select__panel"
            [attr.id]="id + '-panel'"
            [@transformPanel]="'showing'"
            (@transformPanel.done)="
              panelDoneAnimatingStream.next($event.toState)
            "
            [style.transformOrigin]="transformOrigin"
            (keydown)="handleKeydown($event)"
          >
            <ng-content select="rds-select-search-input" />
            <ng-content select="rds-select-option" />
          </div>
        </div>
      </ng-template>
    </ng-container>
  `,
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: SelectAnimations,
                    providers: [
                        { provide: RdsAbstractFormFieldControl, useExisting: RdsSelectComponent },
                    ],
                }]
        }], propDecorators: { multiple: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvYW5ndWxhci1jb21wb25lbnRzL3NyYy9saWIvZm9ybS1maWVsZC9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUNMLFVBQVUsRUFDVixHQUFHLEVBQ0gsS0FBSyxFQUNMLGNBQWMsRUFDZCxJQUFJLEVBQ0osVUFBVSxFQUNWLFdBQVcsRUFDWCxLQUFLLEVBQ0wsUUFBUSxHQUNULE1BQU0sdUJBQXVCLENBQUM7QUFDL0IsT0FBTyxFQUVMLHVCQUF1QixFQUN2QixTQUFTLEVBRVQsS0FBSyxFQUlMLGlCQUFpQixHQUNsQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzdCLE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekQsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFN0UsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDdkQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFHekUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7Ozs7QUEyRWhFLE1BQU0sT0FBTyxrQkFDWCxTQUFRLDBCQUtQO0lBL0VIOztRQXdGOEIsVUFBSyxHQUFHLFlBQVksQ0FBQztLQTJMbEQ7SUF6TEMsSUFDSSxRQUFRLENBQUMsU0FBdUI7UUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FDYiwwSEFBMEgsQ0FDM0gsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxjQUFj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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErRFQ7b0JBQ0QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7b0JBQ3JDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxVQUFVLEVBQUUsZ0JBQWdCO29CQUM1QixTQUFTLEVBQUU7d0JBQ1QsRUFBRSxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsV0FBVyxvQkFBb0IsRUFBRTtxQkFDMUU7aUJBQ0Y7OEJBbUJLLFFBQVE7c0JBRFgsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7XG4gIERPV05fQVJST1csXG4gIEVORCxcbiAgRU5URVIsXG4gIGhhc01vZGlmaWVyS2V5LFxuICBIT01FLFxuICBMRUZUX0FSUk9XLFxuICBSSUdIVF9BUlJPVyxcbiAgU1BBQ0UsXG4gIFVQX0FSUk9XLFxufSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRG9DaGVjayxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUmRzQWJzdHJhY3RGb3JtRmllbGRDb250cm9sIH0gZnJvbSAnLi4vYWJzdHJhY3QtZm9ybS1maWVsZC1jb250cm9sJztcbmltcG9ydCB7IFJkc1NlbGVjdE9wdGlvbiB9IGZyb20gJy4vc2VsZWN0LXR5cGVzJztcbmltcG9ydCB7IFNlbGVjdEFuaW1hdGlvbnMgfSBmcm9tICcuL3NlbGVjdC5hbmltYXRpb25zJztcbmltcG9ydCB7IFJkc0Fic3RyYWN0U2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnLi9hYnN0cmFjdC1zZWxlY3QuY29tcG9uZW50JztcbmltcG9ydCB7IFJkc1NpbmdsZVNlbGVjdE9wdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vc2luZ2xlLXNlbGVjdC1vcHRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyB0YWtlVW50aWxEZXN0cm95ZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlL3J4anMtaW50ZXJvcCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3Jkcy1zZWxlY3QnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgICBAaWYgKHNob3VsZFNob3dWYWx1ZSgpKSB7XG4gICAgICAgIDxkaXYgY2xhc3M9XCJyZHMtZm9ybS1maWVsZF9fc2VsZWN0LXZhbHVlXCIgI3dyYXBwZXJFbGVtZW50PlxuICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICBjbGFzcz1cInJkcy1mb3JtLWZpZWxkX19zZWxlY3QtdHJpZ2dlci12YWx1ZVwiXG4gICAgICAgICAgICByZHMtdHJpZ2dlci12YWx1ZXNcbiAgICAgICAgICAgICNyZHNUcmlnZ2VyVmFsdWVzPVwicmRzVHJpZ2dlclZhbHVlc1wiXG4gICAgICAgICAgICBbdHJpZ2dlclZhbHVlc109XCJ0cmlnZ2VyVmFsdWVzXCJcbiAgICAgICAgICAgIFt3cmFwcGVyRWxlbWVudF09XCJ3cmFwcGVyRWxlbWVudFwiXG4gICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICB9IEBlbHNlIHtcbiAgICAgICAgQGlmIChzaG91bGRTaG93UGxhY2Vob2xkZXIoKSkge1xuICAgICAgICAgIDxkaXYgY2xhc3M9XCJyZHMtZm9ybS1maWVsZF9fc2VsZWN0LXZhbHVlXCI+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzPVwicmRzLWZvcm0tZmllbGRfX3NlbGVjdC10cmlnZ2VyLXZhbHVlIHJkcy1mb3JtLWZpZWxkX19zZWxlY3QtdHJpZ2dlci12YWx1ZS1wbGFjZWhvbGRlclwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHt7IHBsYWNlaG9sZGVyIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICA8ZGl2IGNsYXNzPVwicmRzLWZvcm0tZmllbGRfX3NlbGVjdC1hcnJvdy13cmFwcGVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzcz1cInJkcy1mb3JtLWZpZWxkX19zZWxlY3QtYXJyb3dcIlxuICAgICAgICAgIFtjbGFzcy5yZHMtZm9ybS1maWVsZF9fc2VsZWN0LWFycm93LS1yb3RhdGVdPVwicGFuZWxPcGVuXCJcbiAgICAgICAgPjwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICBjZGstY29ubmVjdGVkLW92ZXJsYXlcbiAgICAgICAgY2RrQ29ubmVjdGVkT3ZlcmxheUxvY2tQb3NpdGlvblxuICAgICAgICBjZGtDb25uZWN0ZWRPdmVybGF5SGFzQmFja2Ryb3BcbiAgICAgICAgY2RrQ29ubmVjdGVkT3ZlcmxheUJhY2tkcm9wQ2xhc3M9XCJjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcFwiXG4gICAgICAgIFtjZGtDb25uZWN0ZWRPdmVybGF5U2Nyb2xsU3RyYXRlZ3ldPVwic2Nyb2xsU3RyYXRlZ3lcIlxuICAgICAgICBbY2RrQ29ubmVjdGVkT3ZlcmxheU9yaWdpbl09XCJvcmlnaW5cIlxuICAgICAgICBbY2RrQ29ubmVjdGVkT3ZlcmxheU9wZW5dPVwicGFuZWxPcGVuXCJcbiAgICAgICAgW2Nka0Nvbm5lY3RlZE92ZXJsYXlQb3NpdGlvbnNdPVwicG9zaXRpb25zXCJcbiAgICAgICAgW2Nka0Nvbm5lY3RlZE92ZXJsYXlNaW5XaWR0aF09XCJtaW5XaWR0aFwiXG4gICAgICAgIChiYWNrZHJvcENsaWNrKT1cImNsb3NlKCk7IG9uQmx1cigpXCJcbiAgICAgICAgKGF0dGFjaCk9XCJvbkF0dGFjaGVkKClcIlxuICAgICAgICAoZGV0YWNoKT1cImNsb3NlKClcIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicmRzLXNlbGVjdF9fcGFuZWwtd3JhcHBlclwiIFtAdHJhbnNmb3JtUGFuZWxXcmFwXT1cIm51bGxcIj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAjcGFuZWxcbiAgICAgICAgICAgIGNsYXNzPVwicmRzLXNlbGVjdF9fcGFuZWxcIlxuICAgICAgICAgICAgW2F0dHIuaWRdPVwiaWQgKyAnLXBhbmVsJ1wiXG4gICAgICAgICAgICBbQHRyYW5zZm9ybVBhbmVsXT1cIidzaG93aW5nJ1wiXG4gICAgICAgICAgICAoQHRyYW5zZm9ybVBhbmVsLmRvbmUpPVwiXG4gICAgICAgICAgICAgIHBhbmVsRG9uZUFuaW1hdGluZ1N0cmVhbS5uZXh0KCRldmVudC50b1N0YXRlKVxuICAgICAgICAgICAgXCJcbiAgICAgICAgICAgIFtzdHlsZS50cmFuc2Zvcm1PcmlnaW5dPVwidHJhbnNmb3JtT3JpZ2luXCJcbiAgICAgICAgICAgIChrZXlkb3duKT1cImhhbmRsZUtleWRvd24oJGV2ZW50KVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwicmRzLXNlbGVjdC1zZWFyY2gtaW5wdXRcIiAvPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwicmRzLXNlbGVjdC1vcHRpb25cIiAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGAsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBhbmltYXRpb25zOiBTZWxlY3RBbmltYXRpb25zLFxuICBwcm92aWRlcnM6IFtcbiAgICB7IHByb3ZpZGU6IFJkc0Fic3RyYWN0Rm9ybUZpZWxkQ29udHJvbCwgdXNlRXhpc3Rpbmc6IFJkc1NlbGVjdENvbXBvbmVudCB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBSZHNTZWxlY3RDb21wb25lbnQ8VD5cbiAgZXh0ZW5kcyBSZHNBYnN0cmFjdFNlbGVjdENvbXBvbmVudDxcbiAgICBULFxuICAgIFJkc1NpbmdsZVNlbGVjdE9wdGlvbkNvbXBvbmVudDxUPixcbiAgICBULFxuICAgIFJkc1NpbmdsZVNlbGVjdE9wdGlvbkNvbXBvbmVudDxUPlxuICA+XG4gIGltcGxlbWVudHNcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIERvQ2hlY2ssXG4gICAgQ29udHJvbFZhbHVlQWNjZXNzb3JcbntcbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHJlYWRvbmx5IF9uYW1lID0gJ3Jkcy1zZWxlY3QnO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBtdWx0aXBsZShfbXVsdGlwbGU6IEJvb2xlYW5JbnB1dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnB1dCAnbXVsdGlwbGUnIGlzIG5vdCB2YWxpZCBhbnltb3JlIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgcmVsZWFzZS4gVXNlICdyZHMtbXVsdGktc2VsZWN0JyBjb21wb25lbnQgaW5zdGVhZC5gLFxuICAgICk7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWQoKTogUmRzU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50PFQ+IHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5zZWxlY3RlZFswXTtcbiAgfVxuXG4gIGdldCB0cmlnZ2VyVmFsdWVzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5lbXB0eSkge1xuICAgICAgcmV0dXJuIFsnJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0aGlzLnNlbGVjdGlvbk1vZGVsLnNlbGVjdGVkWzBdLnZpZXdWYWx1ZV07XG4gIH1cblxuICBvdmVycmlkZSBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBuZXcgU2VsZWN0aW9uTW9kZWw8UmRzU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50PFQ+PihcbiAgICAgIGZhbHNlLFxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgaGFuZGxlQ2xvc2VkS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIGNvbnN0IGlzQXJyb3dLZXkgPVxuICAgICAga2V5Q29kZSA9PT0gRE9XTl9BUlJPVyB8fFxuICAgICAga2V5Q29kZSA9PT0gVVBfQVJST1cgfHxcbiAgICAgIGtleUNvZGUgPT09IExFRlRfQVJST1cgfHxcbiAgICAgIGtleUNvZGUgPT09IFJJR0hUX0FSUk9XO1xuICAgIGNvbnN0IGlzT3BlbktleSA9IGtleUNvZGUgPT09IEVOVEVSIHx8IGtleUNvZGUgPT09IFNQQUNFO1xuICAgIGNvbnN0IG1hbmFnZXIgPSB0aGlzLmtleU1hbmFnZXI7XG5cbiAgICAvLyBPcGVuIHRoZSBzZWxlY3Qgb24gQUxUICsgYXJyb3cga2V5IHRvIG1hdGNoIHRoZSBuYXRpdmUgPHNlbGVjdD5cbiAgICBpZiAoXG4gICAgICAoIW1hbmFnZXIuaXNUeXBpbmcoKSAmJiBpc09wZW5LZXkgJiYgIWhhc01vZGlmaWVyS2V5KGV2ZW50KSkgfHxcbiAgICAgIChldmVudC5hbHRLZXkgJiYgaXNBcnJvd0tleSlcbiAgICApIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnRzIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nIGRvd24gd2hlbiBwcmVzc2luZyBzcGFjZVxuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzbHlTZWxlY3RlZE9wdGlvbiA9IHRoaXMuc2VsZWN0ZWQ7XG5cbiAgICAgIGlmIChrZXlDb2RlID09PSBIT01FIHx8IGtleUNvZGUgPT09IEVORCkge1xuICAgICAgICBrZXlDb2RlID09PSBIT01FXG4gICAgICAgICAgPyBtYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpXG4gICAgICAgICAgOiBtYW5hZ2VyLnNldExhc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9uID0gdGhpcy5zZWxlY3RlZDtcblxuICAgICAgaWYgKHNlbGVjdGVkT3B0aW9uICYmIHByZXZpb3VzbHlTZWxlY3RlZE9wdGlvbiAhPT0gc2VsZWN0ZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5saXZlQW5ub3VuY2VyLmFubm91bmNlKFxuICAgICAgICAgIChzZWxlY3RlZE9wdGlvbiBhcyBSZHNTZWxlY3RPcHRpb248VD4pLnZpZXdWYWx1ZSxcbiAgICAgICAgICAxMDAwMCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgaGFuZGxlT3BlbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gdGhpcy5rZXlNYW5hZ2VyO1xuICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIGNvbnN0IGlzQXJyb3dLZXkgPSBrZXlDb2RlID09PSBET1dOX0FSUk9XIHx8IGtleUNvZGUgPT09IFVQX0FSUk9XO1xuICAgIGNvbnN0IGlzVHlwaW5nID0gbWFuYWdlci5pc1R5cGluZygpO1xuXG4gICAgaWYgKGlzQXJyb3dLZXkgJiYgZXZlbnQuYWx0S2V5KSB7XG4gICAgICAvLyBDbG9zZSB0aGUgc2VsZWN0IG9uIEFMVCArIGFycm93IGtleSB0byBtYXRjaCB0aGUgbmF0aXZlIDxzZWxlY3Q+XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBjYXNlIGlmIHRoZSB1c2VyIGlzIHR5cGluZyxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIHR5cGluZyBzZXF1ZW5jZSBjYW4gaW5jbHVkZSB0aGUgc3BhY2Uga2V5LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAhaXNUeXBpbmcgJiZcbiAgICAgIChrZXlDb2RlID09PSBFTlRFUiB8fCBrZXlDb2RlID09PSBTUEFDRSkgJiZcbiAgICAgIG1hbmFnZXIuYWN0aXZlSXRlbSAmJlxuICAgICAgIWhhc01vZGlmaWVyS2V5KGV2ZW50KVxuICAgICkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1hbmFnZXIuYWN0aXZlSXRlbS5oYW5kbGVDbGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIHNldFNlbGVjdGlvbkJ5VmFsdWUodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLmNsZWFyKCk7XG4gICAgY29uc3QgY29ycmVzcG9uZGluZ09wdGlvbiA9IHRoaXMuc2VsZWN0VmFsdWUodmFsdWUpO1xuXG4gICAgLy8gU2hpZnQgZm9jdXMgdG8gdGhlIGFjdGl2ZSBpdGVtLiBOb3RlIHRoYXQgd2Ugc2hvdWxkbid0IGRvIHRoaXMgaW4gbXVsdGlwbGVcbiAgICAvLyBtb2RlLCBiZWNhdXNlIHdlIGRvbid0IGtub3cgd2hhdCBvcHRpb24gdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIGxhc3QuXG4gICAgaWYgKGNvcnJlc3BvbmRpbmdPcHRpb24pIHtcbiAgICAgIHRoaXMua2V5TWFuYWdlci51cGRhdGVBY3RpdmVJdGVtKGNvcnJlc3BvbmRpbmdPcHRpb24pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMucGFuZWxPcGVuKSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmVzZXQgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbi4gTm90ZSB0aGF0IHdlIG9ubHkgd2FudCB0byBkbyB0aGlzIHdoaWxlXG4gICAgICAvLyBjbG9zZWQsIGJlY2F1c2UgZG9pbmcgaXQgd2hpbGUgb3BlbiBjYW4gc2hpZnQgdGhlIHVzZXIncyBmb2N1cyB1bm5lY2Vzc2FyaWx5LlxuICAgICAgdGhpcy5rZXlNYW5hZ2VyLnVwZGF0ZUFjdGl2ZUl0ZW0oLTEpO1xuICAgIH1cblxuICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcHJvdGVjdGVkIG92ZXJyaWRlIGluaXRLZXlNYW5hZ2VyKCk6IHZvaWQge1xuICAgIHN1cGVyLmluaXRLZXlNYW5hZ2VyKCk7XG5cbiAgICB0aGlzLmtleU1hbmFnZXIudGFiT3V0XG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveUtleU1hbmFnZXIkKSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxPcGVuKSB7XG4gICAgICAgICAgLy8gU2VsZWN0IHRoZSBhY3RpdmUgaXRlbSB3aGVuIHRhYmJpbmcgYXdheS4gVGhpcyBpcyBjb25zaXN0ZW50IHdpdGggaG93IHRoZSBuYXRpdmVcbiAgICAgICAgICAvLyBzZWxlY3QgYmVoYXZlcy4gTm90ZSB0aGF0IHdlIG9ubHkgd2FudCB0byBkbyB0aGlzIGluIHNpbmdsZSBzZWxlY3Rpb24gbW9kZS5cbiAgICAgICAgICBpZiAodGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5hY3RpdmVJdGVtLnRvZ2dsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB0aGlzLmtleU1hbmFnZXIuY2hhbmdlXG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveUtleU1hbmFnZXIkKSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9wYW5lbE9wZW4gJiYgdGhpcy5rZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICB0aGlzLmtleU1hbmFnZXIuYWN0aXZlSXRlbS50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgcmVzZXRPcHRpb25zKCk6IHZvaWQge1xuICAgIHN1cGVyLnJlc2V0T3B0aW9ucygpO1xuXG4gICAgdGhpcy5vcHRpb25TZWxlY3Rpb25DaGFuZ2VzXG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZVVudGlsKHRoaXMub3B0aW9ucy5jaGFuZ2VzKSxcbiAgICAgICAgdGFrZVVudGlsRGVzdHJveWVkKHRoaXMuZGVzdHJveVJlZiksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLm9uU2VsZWN0KGV2ZW50LnNvdXJjZSwgZXZlbnQuaXNVc2VySW5wdXQpO1xuXG4gICAgICAgIGlmIChldmVudC5pc1VzZXJJbnB1dCAmJiB0aGlzLl9wYW5lbE9wZW4pIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgb3B0aW9ucyBhbmQgcmVhY3QgYWNjb3JkaW5nbHkuXG4gICAgLy8gSGFuZGxlcyBjYXNlcyBsaWtlIHRoZSBsYWJlbHMgb2YgdGhlIHNlbGVjdGVkIG9wdGlvbnMgY2hhbmdpbmcuXG4gICAgbWVyZ2UoLi4udGhpcy5vcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uY2hlY2tlZENoYW5nZWQpKVxuICAgICAgLnBpcGUoXG4gICAgICAgIC8vIHNob3VsZCBlbWl0IG9uZSB0aW1lIGlmIHN0YXRlcyBjaGFuZ2VzIGZvciBtYW55IG9wdGlvbnNcbiAgICAgICAgZGVib3VuY2VUaW1lKDEpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5vcHRpb25zLmNoYW5nZXMpLFxuICAgICAgICB0YWtlVW50aWxEZXN0cm95ZWQodGhpcy5kZXN0cm95UmVmKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBvblNlbGVjdChcbiAgICBvcHRpb246IFJkc1NpbmdsZVNlbGVjdE9wdGlvbkNvbXBvbmVudDxUPixcbiAgICBpc1VzZXJJbnB1dCA9IGZhbHNlLFxuICApOiB2b2lkIHtcbiAgICBzdXBlci5vblNlbGVjdChvcHRpb24pO1xuXG4gICAgaWYgKGlzVXNlcklucHV0KSB7XG4gICAgICB0aGlzLmtleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShvcHRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRWYWx1ZVRvRW1pdCgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCA/IHRoaXMuc2VsZWN0ZWQudmFsdWUgOiAobnVsbCBhcyBUKTtcbiAgfVxufVxuIl19